{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/10/hello-world/"},{"title":"Sort Algo - Exchange Sort","text":"Sorting1. 교환정렬 (Exchange Sort)Algorithm : O(n^2)12345678910void exchangeSort(int n, keytype S[]){ index i, j; for (i = 1; i &lt; n; i++){ for (j = i+1; j &lt;= n; j++){ if (S[j] &lt; S[i]){ exchange S[i] and S[j]; } } }} 우선 첫 인덱스에 비교 지점(i)_을 고정해 놓고 끝까지 탐색(j++)_해가며 계속 교환한다. 루프_(for-i)_가 한 번 수행될 때마다 앞 인덱스부터 최소 값이 오게된다. 레벨-2 의 “b &lt; a” 노드는 우측 자식을 갖지 않도록 해야 한다. 앞서 루트에서 이미 해당 연산의 결과를 보였기 때문에, 우측 자식이 있는 경우는 모순인 것이다. 이처럼 가지치기를 해주어야 한다. 우리는 이 점에서 “b &lt; a” 연산이 두 번 시행되었다는 사실을 알 수 있다. SubOptimal한 알고리즘의 경우에는 “b &lt; a”가 참이라는 사실을 알 지 못하므로 이와같은 불필요한 연산이 추가로 수행된다. Every-case Time Complexity 값을 비교함으로써 정렬을 수행하는 알고리즘이므로, 두 숫자 사이의 값 비교 연산이 Basic Operation이 된다. 정렬할 항목의 수가 n이 된다 첫 번째 (for-i) 루프에서는 n-1번(2..n) 의 (for-j) 루프를 수행하고, 두 번째 (for-i) 루프에서는 n-2번_(3..n)_의 (for-j) 루프를 수행한다. 이 처럼 for-j 루프의 수행 횟수는 1씩 줄어든다. 이를 모두 더한 것이 시간복잡도가 된다. 교환 정렬은 항상 위의 모든 연산을 수행하므로, Every-Case Time Complexity는 (n-1)n / 2이다. 즉, O(n^2)이라고 할 수 있다.","link":"/2019/07/10/Sort-Algorithm-Exchange-Sort/"}],"tags":[],"categories":[]}