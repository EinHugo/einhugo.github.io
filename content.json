{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/10/hello-world/"},{"title":"Sort Algo - Exchange Sort","text":"Sorting1. 교환정렬 (Exchange Sort)Algorithm : O(n^2)12345678910void exchangeSort(int n, keytype S[]){ index i, j; for (i = 1; i &lt; n; i++){ for (j = i+1; j &lt;= n; j++){ if (S[j] &lt; S[i]){ exchange S[i] and S[j]; } } }} 우선 첫 인덱스에 비교 지점(i)_을 고정해 놓고 끝까지 탐색(j++)_해가며 계속 교환한다. 루프_(for-i)_가 한 번 수행될 때마다 앞 인덱스부터 최소 값이 오게된다. 레벨-2 의 “b &lt; a” 노드는 우측 자식을 갖지 않도록 해야 한다. 앞서 루트에서 이미 해당 연산의 결과를 보였기 때문에, 우측 자식이 있는 경우는 모순인 것이다. 이처럼 가지치기를 해주어야 한다. 우리는 이 점에서 “b &lt; a” 연산이 두 번 시행되었다는 사실을 알 수 있다. SubOptimal한 알고리즘의 경우에는 “b &lt; a”가 참이라는 사실을 알 지 못하므로 이와같은 불필요한 연산이 추가로 수행된다. Every-case Time Complexity 값을 비교함으로써 정렬을 수행하는 알고리즘이므로, 두 숫자 사이의 값 비교 연산이 Basic Operation이 된다. 정렬할 항목의 수가 n이 된다 첫 번째 (for-i) 루프에서는 n-1번(2..n) 의 (for-j) 루프를 수행하고, 두 번째 (for-i) 루프에서는 n-2번_(3..n)_의 (for-j) 루프를 수행한다. 이 처럼 for-j 루프의 수행 횟수는 1씩 줄어든다. 이를 모두 더한 것이 시간복잡도가 된다. 교환 정렬은 항상 위의 모든 연산을 수행하므로, Every-Case Time Complexity는 (n-1)n / 2이다. 즉, O(n^2)이라고 할 수 있다.","link":"/2019/07/10/Sort-Algorithm-Exchange-Sort/"},{"title":"Lecture Note","text":"LECTURE NOTE - from java to spring특징 Write Once, Run Anywhere 이식성이 상당히 좋다. *.java -&gt; *.class -&gt; interpreter -&gt; output 자바는 쓰레드 기반이다. 현장 투입시 하는 것 빌드 자동화 툴(Maven) 선정 통합개발환경 설치 형상관리 툴(git) 지속적 통합(Jenkins) JDK란 개발 툴 Class 란 설계도. 객체지향이란 Real World의 Object -&gt; 추상화 (Class) 명사적 특징 -&gt; 변수 동사적 특징 -&gt; 메서드 클래스는 객체가 아니다!클래스로부터 실행환경에서 객체를 추출해 낼 수 있다. Instance가 객체다. 클래스에 정의된 변수와 메서드는 클래스가 아닌 인스턴스의 소유다. 응집력은 높아야 하며 결합도는 낮춰야 한다.클래스란 인스턴스를 생성하기 위한 하나의 템플릿 (설계도면) 화면을 담당하는 presentation layer의 클래스가 Business logic을 포함하면 안된다. Presentation -&gt; Business logic -&gt; Data access(Persistence) 클래스 클래스 내부에 public static void main을 가지고 있어야 인터프리트가 가능하다. main을 갖고있지 않는 클래스는 인스턴스를 만들기 위해서 존재한다. 1. 변수1접근지정자 데이터타입 변수명; 데이터 타입 : 숫자형, 문자형, 논리형 byte, short, int, long / float, double / char / boolean 기본 : 값을 담음 (내부적으로는 값을 담는다) 참조 : 주소값을 담음 (값을 직접적으로 할당받을 수 없음) 보통 멤버변수는 Critical Section으로 보고 직접 접근 못하도록 가시성을 부여해준다. 지역변수는 메서드와 라이프사이클을 같이한다. 전역변수는 인스턴스와 라이프사이클을 같이한다. Static 변수는 쓰레드와 라이프사이클을 같이한다. 지역변수는 선언 후 초기화 하지 않으면 문법적으로 에러가 발생한다. 2. 메서드123접근지정자 리턴타입 메서드이름(파라메타_타입){ 업무로직} public / protected / default / private 3. 생성자 Like a Method 메서드가 아니다. VO / ENTITY / DTO VO : Back-end단에서 넘어운 데이터 DTO : Front-end에서 넘어온 데이터 (Data Transfer Object) 정형화 되어있지는 않으나 input parameter를 받아올 때 특정 멤버변수를 제외하고 null로 받아서 객체로 넘겨준다면 dto를 사용한다.또한, parameter의 수가 많지 않다면 map에 담아서 컨트롤러까지 넘겨주기도 한다. 레이어 Presentation LayerBusiness LayerPersistence Layer 각 레이어는 각각의 class를 갖는다. Persistence Layer는 DB와 통신한다. ResultSet을 Instance로 만들어야 한다. 1개의 레코드 = 1개의 인스턴스 즉, 현장에서는 테이블 스키마와 동일한 VO를 만드는 경우가 많다. Collection API(ex. 배열)에 담아서 다음 layer에 전달한다 각 클래스의 관계를 명확하게 이해하자! Controller : Presentation Layer (받는 곳)View : Presentation Layer (보여주는 곳)Model : Business &amp; Persistence Layer 생성자 new 연산자 뒤에서만 사용이 가능하다멤버변수에 대한 초기화를 담당한다기본생성자 / 스페셜 생성자 스페셜 생성자는 기본 생성자를 먼저 만들고 쓰는게 좋다 오버로딩 매개변수의 타입과 갯수가 달라야 한다오버로딩된 메서드의 업무 로직은 동일해야 한다 JVM JVM은 메모리 섹터로 이루어져 있다.다섯개의 메모리 영역이 있다. Static / Method Area Stack Heap - Literal(Constant) Pool 실행 순서 javac ~.javajava ~ 실행 할 경우 각 클래스에서 Static 키워드가 붙은 메서드와 변수, 일반 메서드가 Static / Method Area에 올라온다. public static void main(String[] args) 메서드를 찾아서 Execution Stack에 올린다 가비지 콜렉터 참조가 끊어진 객체들이 쌓여서 메모리 가용성이 떨어지면 GC 쓰레드가 작동한다.finalize() 메서드를 오버라이드해서 명시적으로 호출할 수는 있으나 그 실행 시점은 랜덤이다. 리터럴 변수에 할당되는 값문자(‘’), 문자열(“”), 정수, 실수, 논리(true / false) 파라메터 / 매개변수 Parameter : 전달되는 값Argument : 함수에 정의된 변수 Heap에 매개변수 값이 들어간다. (Literal Value) Has-A / Use-A Has-A객체의 라이프사이클이 나와 같을 때Use-A객체의 라이프사이클이 나와 같지 않을 때 객체지향의 특징 - 은닉화 / 상속 / 다형성 / 추상화 은닉화 : 객체의 타입 등 정보를 감출 수 있어야 함. (추상화와 연계되어 있음) Information Hiding 상속 : super(부모클래스) / this. 부모는 자식에게 필요로 되어지는 공통의 기능들을 내려준다. (IS-A 관계)인어공주 IS-A 사람 내려갈수록 클래스는 구체화, 올라갈수록 클래스는 일반화(추상화) 타입 : 부모 &gt; 자식 포함관계 : 부모 &gt; 자식 자바는 컴파일 언어 -&gt; 컴파일 타임에 Data Type을 체크한다. WEB FRAMEWORK들은 코드 상에 extends, implements 가 없더라도 그러한 역할을 해준다는 것을 알자. 다형성 : 관리의 효율성을 위해서 객체의 다형성 메서드의 다형성 (오버로딩 / 오버라이딩) 매개변수의 다형성 항상 캐스팅을 생각하자 추상화 : 구현을 감춘다. Implementation Hiding 추상클래스 / 인터페이스 실 타입을 숨기고, 명세는 동일하지만 그 구현을 감춘다 부모 클래스는 인스턴스를 생성하는 경우가 많지 않다. 배열 [★문제 나옴] 객체로 취급 fixed size same type index 0 부터 다형성을 적용하여 배열에 여러 타입의 데이터를 넣었을 경우 런타임시점에 instanceof 키워드로 리얼타입을 체크한다 반복을 수행하는 방법 for-loop enhanced for loop (for-each) : JIT compiler에 의한 내부순환자 iterator : 가장 빠름 파일입출력 [★문제 나옴]추상클래스 / 인터페이스 공통점 : 표준의 역할을 하기 위함 차이점 : 객체 생성이 되지 않음 추상클래스 : 변수 + 메서드를 포함하고 있음 자식클래스는 모든 추상메서드를 오버라이드 해야만 인스턴스 생성 가능 모든 서브타입이 기능을 공유하고, 특정 기능은 동일한 구현을 공유해야 할 때 추상클래스를 쓰면 용이하다. 인터페이스 : 상수(잘 안씀) + 추상 메서드 다중 구현 가능 상속받는 클래스는 인터페이스의 모든 추상메서드를 오버라이드 해야함 ENUM 열거형 데이터 타입public static final 로 상수를 선언했을 때, 다른 사용자가 악의적으로 엉뚱한 상수값을 넣는 것을 방지 할 수 있음 디자인패턴 싱글톤 패턴 : 무분별한 객체 생성을 막기 위해 필요 커맨드 패턴 팩토리 패턴 빈(Bean) 개발자가 생성하지 않고 생성된 객체 싱글톤의 문제 : Bottleneck Bean 객체의 생성을 Singleton이 아닌 Request시 마다로 할 수 있음 (WAS) Activated / Deactivate 할 수 있음 예외 (Exception) Object &lt;- Throwable &lt;- Exception Compile Runtime T-C-F-T-C 형식을 즐겨 쓴다결과에 대해 명확히 이해한 후에 Throws를 할지 T-C를 할지 결정해야 한다.T-F 구문이 있을 수 있다 (내가 직접 예외를 던질 경우(throws)에 사용한다) Collection API fixed size가 아닌 배열. Object만 담을 수 있다. Java 5 버전 이후에는 auto-Boxing이 되므로 int도 담을 수 있다. Same Type이 아니어도 된다. size() 메서드를 이용해서 크기를 알 수 있다. Index를 쓸 필요가 없다. List - Vector, Linked, ArrayList 중복 허용, Natural Order Set - HashSet 중복 x, 순서 x Map - HashMap(key, value) 중복 x, 순서 x Vector / ArrayList의 차이 쓰레드 WAS 서버가 T-S를 보장한다.그렇기 때문에 웹에서는 멤버변수를 잘 쓰지 않는다. Stream 데이터가 지나다닐 수 있는 통로.System.out.printl() &lt;-&gt; System.in.read() java.io.* Byte 형식으로 입출력하는 스트림 (한글을 사용하면 깨진다) xxxStream Character 형식으로 입출력하는 스트림 xxxReader / xxxWriter Byte Stream을 활용한 객체 스트림 ObjectInput/OutputStream 콘솔 입출력, 파일 입출력, 원격 통신 자바에서 객체를 전송할 때는 Serializable Interface를 Implements 해야 함.Marker Interface : 인터페이스이지만 추상메서드가 없음.객체를 ByteStream으로 보내고 받음.Stream 자체와 transient 키워드가 붙은 변수는 직렬화가 되지 않는다. Thread 구현 방식 Thread Class Runnable Interface run() : Thread의 수행 업무 쓰레드는 동시성과 제어가 중요한 관점 [출처 : https://www.javamadesoeasy.com/2015/03/thread-states-thread-life-cycle-in-java.html] 스케쥴링 방식 Time Slice 방식 (Ordering X 랜덤) Turn Around 방식 (Ordering O 메모리 순위로) Method join() : 데몬쓰레드가 기다림 sleep() : 쓰레드를 재워둠 wait(), notify() : Syncronized Block에서만 사용 가능 notifyAll() : 모든 쓰레드가 깨어남 threadIsAlive(), currentThread() : 현재 동작하는 쓰레드를 알 수 있음 interrupt() : 쓰레드를 킬함 JDBC Driver loading Connection (url, user, pwd) Statement (SQL) 실행 excuteQuery() : resultSet -&gt; select excuteUpdate() : int -&gt; insert / update / delete ResultSet 핸들링 Close() 위 절차는 모두 Exception을 발생시킨다. try ~ catch 가 필요하다. 이러한 것들을 모두 감싸는 프레임워크가 myBatis. connection() ~ close()의 작업이 반복적으로 실행되면 오버헤드가 심해지므로 현업에서는 Connection Pool을 사용한다. 백엔드의 레이어 Presentation Layer Servlet.java (Controller) java + html 분기하는 것이 Controller의 역할이다. xxx.jsp (View) html + java Business Layer (Model) xxxServiceImpl Persistence Layer (Model) xxxImpl Front-Controller Pacade Pattern / Delegate Pattern request를 Factory로 넘겨서 Controller를 생성함 Web Servlet : Controller의 역할 JSP : View의 역할 Web Server + Container(java 실행환경) = WAS Container Catalina : Servlet 동작 Jasper : JSP 동작 Dynamic Web Project http: //server_ip/contextName/servletName or xxxxx.jsphttp: //server_ip/contextName/xxxxx?key=value&amp;key=valueURL or URI ? queryString lib : 라이브러리들 web.xml : Deploy Descriptor build : Output Java Resources src/main/java : 자바 파일 src/resources : xml 파일, sql 파일 등 src/test : 테스트 파일 (ex. jUnit) Servlet &lt;- GenericServlet &lt;- HttpServlet Servlet의 메서드 3개 init() service() doGet() doPost() destory() : re-compile 될 때 등 사용. 보통 외부자원과의 연결을 끊어주는 역할을 수행함. HttpServlet &lt;- MyServlet위의 3개의 메서드를 오버라이딩해서 사용한다. 최초의 request가 들어왔을 때 객체가 생성(LazyLoading)되고, 이후에는 init() 이후에 thread만 매번 생성된다. 일반 xxx.java는 Request, Response 객체를 핸들링 할 수 없으나, Dispatcher Servlet(Front-Controller)로 부터 Delegate 함으로써 Controller 역할을 수행 할 수 있게 된다. 각 Controller는 사용자 Request URL을 매핑해서 사용한다. 데이터 Validation Check 데이터에 대한 유효성(Validation) 체크는 네트워크 트래픽을 낭비하지 않기 위해 프론트엔드에서 Script로 하는 것이 좋다. 백엔드에서도 Filter를 이용해서 유효성을 체크해야 한다. 즉, 컨트롤러의 실질적인 일이란 객체를 만들어서 서비스에 맡기는 것이다. (Model과 dependency를 갖는 것이다.) 화면 분기 방식 redirect forward Forward라면 Request에 데이터를 심어서 Response에서 그 데이터를 사용할 수 있게끔 한다.Redirect 하는 상황에서 데이터를 공유하려면 Request가 아닌 Session에 데이터를 심어야 한다. Java와 jsp간 데이터 교환 방법 컨테이너 내부에 객체를 공유할 수 있는 공간이 있음 컨테이너 내부의 4가지 Scope 영역 Application Context : 컨테이너 내부에서 동작하는 객체를 유지 (server가 shutdown 되기 전까지 - ex. 로그인 중인 사용자의 정보), 가장 넓은 Scope를 가진다. Session Context : Last Access Time으로부터 일정 기간동안 유지된다. Request : Request는 해당 요청이 처리되면 데이터가 사라진다. (Model(@ModelAttribute), RedirectAttributes) Page : 자기 페이지 내부에서만 작동하는 Scope. 제일 작은 범위. 서블릿이 자체적으로 JSP에 데이터를 던져줄 수 없으므로, Servlet이 어딘가에 심어놓은(setAttribute()) 데이터를 JSP가 가져오는(getAttribute()) 것이다. JSP에서 해당 데이터를 이용하기 위해서는 JAVA의 객체를 사용해야 하므로, JAVA의 코드를 JSP(HTML) 내에 삽입하기 위한 태그들이 존재하게 되는 것이다. 자동로그인의 경우는 Cookie를 이용해서 백엔드에서 Interceptor로 작동된다. 프론트엔드에서 시각화 하는 방법은 script를 사용한다. 즉, JAVA의 객체를 script가 가져다 쓸 수 있게끔 해야 하기 때문에 JSON과 같은 방식이 필요하다. HTML HTML에서 서버와 통신하는 방법은 3개가 있다. a tag get 방식 form tag method 속성으로 action의 방식을 설정 가능 input tag name 속성에 값을 담아서 넘긴다. 현업에서는 일반적으로 name과 id의 이름을 동일하게 준다. name Attribute, Table Column, DTO Field는 동일하게 주어야 한다 AJAX JSP JSP에는 기본적으로 4개의 tag가 있다. &lt;%@ : Directives tag (지시자) page (import) include taglib &lt;%! : Declaration tag (선언문) 변수, 메서드 정의 &lt;% : Scriptlet tag 서블릿의 service()와 동일한 역할을 하는 태그 request, response등 내장객체를 이용한 코딩이 가능해짐 &lt;%= : Expression tag 출력시 사용. semicolon 사용 불가 그러나 위의 태그들을 사용하여 java 코드를 넣을 경우 뷰를 처리하는 JSP 코드가 너무 복잡해지는(이질감이 드는) 문제점이 발생-&gt; JSTL, EL JSTL + EL EL (Expression Language) : 내장객체와 속성 값을 가져오기 매우 편함 직접적으로 속성 값을 가져오는 것이 아니고 getter를 사용하여 가져온다. 내부에 연산자를 사용할 수 있다. JSTL (JSP Standard Tag Library) jstl/core : 논리적 처리, 변수 지원, 흐름 제어 등의 태그들 jstl/functions : EL에서 사용 가능한 함수 태그들 1234567891011${ param.name }&lt;c:if test = \"${ testSession ne null }\"&gt; ${ testSession[\"id\"] } &lt;c:out value=\"&lt;h2&gt;${ testSession.id }&lt;/h2&gt;\" escapeXml=\"true\" /&gt;&lt;/c:if&gt;&lt;c:if test=\"${f:length(list) &gt; 0}\"&gt; &lt;c:forEach var=\"obj\" items=\"${list}\"&gt; ${obj.id} &lt;br/&gt; &lt;/c:forEach&gt;&lt;/c:if&gt; 세션과 쿠키 세션 (Session) : 서버에 저장, 객체도 저장 가능 쿠키 (Cookie) : 클라이언트에 저장, 문자열만 저장 가능 세션은 공통 업무와 보안 문제를 고려할 때 사용 Script 페이지가 멈춰있는 상태에서 (JSP를 문서로 봄) Document를 건드리는 기술 ex) 동적인 페이지 구성 / 입력 값에 대한 유효성 체크 + Script를 이용한 서버와의 통신. But, Response가 없음. 응답이 Request에 담겨있다. (페이지의 Reloading이 발생하지 않음)-&gt; 비동기 통신방식(AJAX) XML(복잡) -&gt; JSON JAVA의 객체를 Object로 관리하기 위해서는 형식을 맞춰주어야 한다. 서버에서 Session/Request Scope에 데이터를 JAVA type으로 심는 방식이 아니고 JSON 형식으로 변경해서 내려주어야 한다. JQuery1234567891011$(document).ready(function() { $(\"#btn\").click(function() { /* console.log(obj); console.log(ary); $(\"#result\").text(obj.id + \" \" + obj.pwd); */ $.each(ary, function(idx, data) { $(\"#result\").append(\"&lt;H1&gt;\" + obj.id + \" \" + obj.pwd+ \"&lt;/H1&gt;\"); // $(\"#result\").html(\"&lt;H1&gt;\" + obj.id + \" \" + obj.pwd+ \"&lt;/H1&gt;\"); }); });}); AJAX1234567891011$(\"#ajaxBtn\").click(function() { $.ajax({ url : \"./ajaxCtrl\", type : \"post\", data : { maker : $(\"#maker\").val()}, dataType : \"json\", success : function(obj){ alert(obj); } });}); 비동기 방식으로 통신할 때 객체를 넘기면(Response를 넘기지 않으면) MVC를 타지 않는다.@ResponseBody 키워드를 사용하면 Jackson 라이브러리가 JSON 형식으로 변환해서 보내준다. 12345@RequestMapping(\"/doJSON.sinc\")public @ResponseBody ProductVO doJSON() { ProductVO vo = new ProductVO(\"샘플\", 30000); return vo;} 주석 HTML : &lt;!– JSP : &lt;%– 클라이언트가 볼 수 없음, 파싱 시 에러 방지 Maven https://mvnrepository.com/ Spring Inversion Of Control (제어의 역행) Dependency Injection Dependency Lookup Container를 Setting하는 방법 XML (Schema) Annotation 위의 방법들을 이용해서 Ctrl &lt;- Service &lt;- DAO를 Dependency Injection함 Presentation Layer(Ctrl)의 XML 1개servlet-context.xml : resources, views Business Layer(Service, DAO)의 XML 1개root-context.xml : DB Property 설정, Service/DAO 객체 등록 -&gt; 총 2개의 Spring 설정 XML 파일이 생성된다. Web.xml : 프로젝트에 대한 환경 설정. context 파일과 Servlet(Front Controller) 등록. -&gt; Factory의 역할을 함 Annotation을 사용해 서블릿 등록 가능 -&gt; 최종적으로 Zero Configuration 지향 가능 의존성 주입 방법 @Resource : Java 표준. name으로 식별이 가능함 @Autowired : Spring. Ambiguity 문제 발생 가능성 (Type Check -&gt; Variable Name Check) @Inject @Qualified 12345&gt; &lt;bean&gt;&gt; &lt;property&gt;&gt; &lt;constructor-arg&gt;&gt; &lt;/bean&gt;&gt; -&gt; Setter Injection (Property Injection) LookUp(main Class의 흐름) 역시 Spring이 해준다. AOP SpringMVC [출처 : https://iotsw.tistory.com/tag/HandlerMapping] web.xml(Deploy Decriptor)에 Dispatcher Servlet을 등록함 스키마 기반으로 구성하면 multi-action Controller를 구현할 수 없음 -&gt; Controller Annotation Controller는 Request에 대해 화면을 분기해줌 servlet-context.xml에 ViewResolver가 등록되어 있으며, annotation-driven으로 Mapper도 등록되어 있음 root-context.xml이 모델/DAO에 대한 설정을 지니고 있음 이 모든 것들이 web.xml에 의해 로드되므로 스프링의 컨테이너가 사용가능해짐 Client -&gt; Dispatcher Servlet-&gt; Handler Mapping&lt;-&gt; Controller 컨트롤러 메서드의 리턴타입은 3개 ModelAndView String Void Request 되는 URI과 같은 JSP를 찾음. (경로 주의) -&gt; ViewResolver-&gt; View 기본 페이지 분기는 Forward Ctrl의 Parameter는 지정하기 나름 Model 객체가 Request Scope을 가짐 객체생성에 관련한 Annotation @Component @Controller @Service @Repository JUnit 모듈 단위테스트를 용이하게 도와주는 라이브러리 filter, interceptor, AOP[출처 : https://goddaehee.tistory.com/154] filter : Web Container에서 동작, Servlet 이전사용자의 요청이 post 방식일때만 작동한다. -&gt; get 방식에서는 한글을 가급적 사용하지 않는다. ex) 한글 Encoding 작업 interceptor : Dispatcher -&gt; Controller 이전 (servlet-context) Request 정보를 지니고 있다가 로그인 후 이용 가능한 장점도 있다. AOP : 서비스 이전 (root-context) 1234567891011121314public class TestInterceptor extends HandlerInterceptorAdapter{ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {// if(request.getSession().getAttribute(\"loginUser\") == null) {// redirect// } System.out.println(\"interceptor &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pre\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"interceptor &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; post\"); }} 12345678&lt;beans:bean id=\"sampleInter\" class=\"com.sinc.project.interceptor.TestInterceptor\" /&gt;&lt;interceptors&gt; &lt;interceptor&gt; &lt;mapping path=\"/user/login.sinc\"/&gt; &lt;beans:ref bean=\"sampleInter\"/&gt; &lt;/interceptor&gt;&lt;/interceptors&gt; 동적 쿼리123456789101112131415&lt;select id=\"search\" parameterType=\"map\" resultType=\"board\"&gt; SELECT SEQ, TITLE, WRITER, TO_CHAR(REGDATE, 'RRRR-MM-DD') AS REGDATE, VIEWCNT FROM SPRING_BOARD_TBL &lt;where&gt; &lt;if test=\"#{type} == 'title'\"&gt; TITLE LIKE '%' || #{title} || '%' &lt;/if&gt; &lt;if test=\"#{type} == 'writer'\"&gt; WRITER LIKE '%' || #{keyword} || '%' &lt;/if&gt; &lt;/where&gt; ORDER BY 1 DESC&lt;/select&gt;&lt;-- WHERE SALARY &lt;![CDATA[ &gt; ]]&gt; 1000 --&gt; 문제 배열(2차원), 조건처리, 스트림 자바, SQL, 웹, 스프링","link":"/2019/07/10/Lecture Note - from java to spring/"}],"tags":[],"categories":[]}