{"pages":[],"posts":[{"title":"(읽는 중) Git for Humans - 인간다운 Git (2016, David Demaree)","text":"읽는중","link":"/2019/07/25/Books/190725 - Git for Humans/"},{"title":"(읽는 중) Clean Code - 클린코드 (2008, Robert C. Martin)","text":"부제 - A Handbook of Agile Software Craftmanship&quot;Honesty in small things is not a small thing.&quot; 읽는중","link":"/2019/07/28/Books/190728 - Clean Code/"},{"title":"(읽는 중) The Art of Readable Code - 읽기 좋은 코드가 좋은 코드다 (2011, Dustin Boswell / Trevor Foucher)","text":"읽는중","link":"/2019/07/28/Books/190728 - The Art of Readable Code/"},{"title":"Cloud - Basic","text":"클라우드 컴퓨팅 = Virtualization 인터넷을 통해 리소스와 애플리케이션을 On-Demand 하게 사용한 만큼 요금을 내는 서비스 IaC (Infrastructure as code)가 가능해진다. 클라우드 컴퓨팅의 장점 초기 투자비용이 없으며 운영 비용을 절감시킬 수 있고 탄력적인 운영과 확장이 가능해지며 (Auto-Scaling) 인프라 구축에 민첩성을 갖게되고 불필요한 인프라 관리 업무에 신경을 쓰지 않아도 되며 글로벌 확장에 이점을 지닌다. (CDN, Cloudfront) 핵심 역량에 집중하여 빠르게 실험하고 저렴하게 실패하며 Lean한 운영을 하자 [출처 : https://www.slideshare.net/AmazonWebServices/big-data-and-the-cloud-a-best-friend-story/38-Elastic_Compute_Capacity_On_and] 주의 : 온프레미스(On-premise) 시스템에 비해 초기 투자 비용을 아낄 수 있으나, 서비스에 따라서 결과적으로 동일한 수준의 비용을 지불하게 될 수 있다. (ex. Auto-Scaling, 24시간 가동) 산업의 주요 변화 개인 최적화 맞춤형 서비스 경쟁력 확보 내부 효율성 증대 (DevOps) AI / ML StackAI 애플리케이션 서비스 Vision Rekognition Image ReKognition Video Textract Speech Polly Transcribe Language Translate Comprehend ChatBot LEX ForeCasting Forecast Recommendation Perionalize ML 플랫폼 서비스 Data labeling (Ground Truth) Algorithms &amp; models (AWS 마켓플레이스) ML 프레임워크 텐서플로우 케라스 파이토치 mxnet gluon MFA(Multi-Factor Authentication) 체계적인 관리 및 보안 강화를 위해 사용 루트계정(AWS 계정)을 그대로 모두가 사용한다면 보안 이슈가 발생할 수 있다. -&gt; IAM(Identity and Access Management) 기능을 이용하여 별도의 기본 계정을 생성해서 사용할 것이다. IAM 검색 -&gt; Group 생성 -&gt; User 생성 대시보드 -&gt; MFA 활성화 스마트폰 Google Auth App 다운로드 QR코드 스캔 -&gt; 비밀번호 code 1 입력 / 기다렸다가 code 2 입력 Finish (최종적으로 Root 계정과 기본 IAM 계정 모두 MFA 기능을 적용해야 한다.) 이와 같이 모바일의 Google Auth와 MFA를 연결하면 기기와 싱크되기 때문에 시간대가 맞지 않다면 로그인 할 수 없다. 루트 계정은 Billing 정보 확인 외에는 사용하지 않는다. 이후의 모든 것은 일반 계정에서 진행한다. VPC (Amazon Virtual Private Cloud) VPC 위자드를 사용하면 편하게 아래 설정을 할 수 있으나, 공부하는 입장에서 명확히 이해 못할 수 있기 때문에 별도로 설정 할 것이다. 모든 셋팅 이전에 리전을 확인해야한다. CIDR (Classless Inter-Domain Routing) 설정하려고 하는 가장 큰 IP의 주소. 실제 물리환경에서도 사용하는 IP. (실제로는 subnetting을 16까지가 아닌 8까지 주고 있음.) 10.0.0.0/16 172.31.0.0/16 192.168.0.0/16 관련 내용 : IPv4, NAT, Subnet, AZ, HA AWS 의 구성Region (리전) -&gt; Availability Zone (가용 영역, IDC 개념) ex) northeast-2bnortheast-2a 이처럼 AZ를 나눠서 서비스를 구성하면 HA(High Availability)를 유지할 수 있다. 최종 목표 : 서버의 물리적 이중화 Default VPC (실제 서비스에서는 Default VPC를 그냥 쓰지 않는다) 이미 노출되어 있기 때문 VPN을 사용할 때 IP 대역이 충돌할 수도 있다. ex) 172.x.x.0 &lt;-&gt; 172.x.x.1 테스트 용으로 사용하기도 한다. 직접 구성한 Network 설정 IP Address를 몇개를 확보할 것인가? /24 로 Subnet했을때 아마존에서 이미 몇개의 IP를 사용하기 때문에 (254개가 아닌) 251개의 IP를 사용할 수 있게 한다. 기본 IP Address의 갯수가 적으면 AutoScaling같은 확장 기능을 사용하기가 어렵다. AWS Lambda (컨테이너 기반)도 IP를 할당받기 때문에 IP Address에 여유가 없으면 장애가 난다. On-Premise 구성에서는 IP Address를 필요한 만큼만 할당하지만, Cloud 환경에서도 그렇게 셋팅한다면 장애가 발생할 수 있는 것이다. 한번 네트워크를 잘못 설계하고 서비스를 띄우면, 위의 리소스를 다 걷어내고 다시 해야 하므로 신중하게 설계해야 한다. AWS는 All DNS 기반으로 서비스가 이루어진다. Public IP, Public DNS를 통해 EC2로 들어오게 된다. All DNS AWS에서 IP는 늘 변한다. Auto-Scaling 때문 그러므로 Load-Balancer를 통해서 연결된다. 즉, EC2의 IP를 알 필요가 없다. Name Server의 CNAME 값으로 LB에 연결된다. (DNS 서버에 도메인을 매핑해 놓는 것이다.) VPC를 Gateway에 Attach 해 놓는다. Gateway -&gt; VPC -&gt; LB -&gt; EC2 클라우드 비용 절감 Month-to-Date의 비용을 적게 해서 Forecast(미래 예측 금액)을 줄인다. Limit을 걸어서 한도를 건다. (프리티어의 경우 0$로 설정) EC2, RDS 비용이 AWS에서 가장 많이 나온다. EC2 비용을 줄이는게 관건이다. Trusted Advisor 비용, 성능, 보안, 이중화구성, 서비스제한까지 볼 수 있다. Security Group 설정 : 특정 IP만 접근 허용 / Https 접속 설정 등 Service Limits : 미리 필요한 제한을 해제해 둘 필요가 있다 제공 서비스EC2 구매 옵션 On-Demand Instance : 사용한 인스턴스에 대한 비용만 지불 트래픽 예측이 불가능할 경우 Reserved Instance (예약 인스턴스) : 선납 (70% 절약) 항상 켜두어야 하는 인스턴스 Spot Instance (스팟 인스턴스) : 입찰 (최대 90% 절약) 시간 제한이 없는 배치성 워크로드 스팟은 꺼질 수 있다. 중요한 것은 RightSizing이다. 돌려보고 확인해보고 롸잇사이징! 다시 확인 비용 절감 T 타입, M 타입 : 범용C 타입 : 컴퓨팅 (CPU) -&gt; WASR 타입 : 메모리 -&gt; Mem CacheI, D, H : I/OG, P 타입 : 그래픽 -&gt; MLEC2 Bare Metal : 물리서버 AWS Instance Scheduler 사용하지 않는 시간에 인스턴스를 꺼 둘 수 있다. AWS 스토리지 오브젝트 스토리지 블록 스토리지(EBS) 프로비저닝된 IOPS SSD 자잘한 디스크 사용량이 너무 많을 경우 IOPS를 미리 돈주고 사서 띄우는 경우가 있다. IOPS : Input/Output Operations Per Second 엣지 로케이션 (Edge Location) CDN(CloudFront)를 제공하기 위해서 구축해놓은 서버 Region, AZ와는 다른 개념.","link":"/2019/07/22/Cloud/190722 - Cloud - Basic/"},{"title":"Cloud - Architecture","text":"1000만 사용자를 위한 클라우드 서비스 구성사용자가 1명 이상네임 서버 등록 Route 52 DB 서버 분리 Self-managed : EC2 Slow Query 등의 문제에 대한 모니터링을 스스로 모두 해야함 Fully managed (DB Instance) : RDS (MySQL, Oracle, MS-SQL, Postgresql … ) 비용적으로 비싸나 훨씬 편하다 DynamoDB (NoSQL - KEY:VALUE. SNS 등에서 사용) Neptune (GraphQL) DocumentDB (MongoDB 호환) Aurora Serverless On-Demand, Auto-Scaling이 가능한 DB 개별적 AZ 구성이 필요 없도록 클러스터로 구성 읽기 전용 복제본을 만들 수 있음 (부하 분산) 참고 https://medium.com/hbsmith/aws-aurora-%EB%8F%84%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EB%AA%87%EA%B0%80%EC%A7%80-%EC%82%AC%EC%8B%A4-45eb602bad58 http://woowabros.github.io/study/2019/01/19/aws-global-database.html 연간 데이터 양이 5TB가 넘을 때 NoSQL 굉장히 낮은 지연시간이 요구되는 어플리케이션의 경우 비 관계적인 데이터 스키마 구조가 필요 없을 때 빠른, 대량의 데이터 발생 회원 가입/등록 시 Amazon Cognito 회원의 인증과 자격증명을 다뤄줌 OAuth 가능 모바일 사용에 특화됨 보안 체크리스트 CloudTrail IAM 로그 관리 GuardDuty, Shield 방화벽 Certificate Manager SSL 인증서 통합 관리 무료로 1개 생성 가능 유료는 2048bit 이상 / 무료는 1024bit 베리타스 등에서 구입한 인증서를 넣을 수 있음 로드밸런서와 연동 가능! -&gt; HTTPS 구성이 훨씬 간편해짐 Key Management Service 암호화 key-value 관리 서비스 AWS Config 위의 자원들에 대한 사용 정보를 관리 사용자가 100명 이상DB 서버를 RDS로 관리사용자가 1000명 이상 2-Tier 구조 (3-Tier는 WAS를 두었을 때) 부하 분산 Elastic Load Balancing 물리적으로는 L4 스위치 Classic Load Balancer TCP:8080 등을 로드밸런싱 하고 싶을 때 고전적인 포트번호 기반 로드밸런싱 Application Load Balancer 단순 어플리케이션을 로드밸런싱 하고 싶을때 HTTP, HTTPS 통신 가능 (Certi Manager와 연동시키기 편리) 웹소켓 등 컨텐츠 기반 라우팅 Network Load Balancer 직접 LB를 구성할 경우에는 HA Proxy로 구성 (고정 IP 셋팅을 위해) 참고 : https://d2.naver.com/helloworld/284659 기존 방식 ab.a.com ac.a.com 도메인 방식으로 구성됨 (도메인 주도 개발 Domain-Driven) DNS에 대한 많은 등록, 잦은 접근이 요구된 RESTful 통신 (API 통신) MSA (MicroService Architecture) URI 방식으로 구성됨 -&gt; ALB +. CPU, memory 등에 퍼포먼스가 나오지 않을 때 한번은 stop 할 수 밖에 없으므로 Scale-up이 요구되는 경우도 있음 사용자 10,000명 이상이중화 서버 이중화 AZ를 분리하여 서버를 이중화시킴 DB 서버 이중화 DB 서버와 Web 인스턴스 사이에 LB 기능이 구성되어 있음 Active, Standby (Multi-AZ) 각각의 RDS 인스턴스에 (읽기 전용)Replica를 두어서 부하 분산 LB 이중화 AWS에서 알아서 해줌 On-Premise 환경에서는 L4 스위치를 4개 둠 (Public : 공인 IP 응답용 2개 (Virtual IP에 대응) / Private : 내부용 2개) 두 Layer 사이에 방화벽을 둠 (FireWall Load Balancer) 정적 컨텐츠 분리 S3, CloudFront를 사용하여 정적 컨텐츠 분리 S3 - 스토리지 jpg, css, html 등 서버리스로 제공 용량의 무한 확장이 가능 오브젝트 당 5TB HTTPS 제공 (Compliance가 요구하는 암호화) CoudFront 낮은 TTL(Time-To-Live) SSL 인증서 가능 캐싱 가능 동적 / 정적 컨텐츠 / 비디오 스트리밍도 가능 동적 컨텐츠 캐싱은 변경된 내용을 copy 하는 형식으로 구성 ex) 1초에 5번 변경되는 내용 -&gt; 1초에 5번 캐싱 -&gt; 트래픽 증가 -&gt; CDN 의미 없음 더 많은 부하 분산 ElastiCache In-Memory Database (ex. Redis) 장바구니 정보 등이 서비스 장애 시 날라가지 않도록 날아가도 상관 없다 / 빠른 응답을 원할 때 사용 DynamoDB 로그 정보를 남겨서 후에 활용하고 싶을 때 Auto-Scaling 적용 CLI 기반으로 적용 가능 Management Console로도 가능 사용자가 50만명 이상자동화 적용 Code 셋트 CodePipeline : 파이프라인으로 아래 작업을 관리 CodeCommit : 형상관리 (like git) CodeBuild : 빌드 CodeDeploy : 배포 CodeStar : 위의 기능들을 한번에 적용 가능 단점 : 우리가 원하는 변경사항대로 수정이 쉽지 않음 개발(Cloud9) -&gt; 형상관리(CodeCommit) -&gt; 빌드(CodeBuild) -&gt; 테스트(3rd-Party Tool, 젠킨스 등) -&gt; 배포(CodeDeploy) 이벤트 기반 컴퓨트 Lambda 내부적으로 컨테이너 형식 관리 Event-Driven 작동 인프라 없이 소스코드만 존재 코드가 잘 작동하는지 에러로만 확인해야함 (기존) AWS X-Ray : 에러파악, 병목현상 추적 가능 서비스 사용자가 100만명 이상인스턴스 분리 Worker 인스턴스 분리 Task 처리를 위해 Web Instance는 웹 처리에만 집중 App 인스턴스 분리 내부 처리를 위해 -&gt; 사용자가 1,000만명 이상","link":"/2019/07/23/Cloud/190723 - Cloud - Architecture/"},{"title":"Oracle - SQLTools 설치","text":"오라클 클라이언트 툴 SQLTools 설치이 글에서는 Windows 환경에서 오라클 클라이언트 무료 툴 SQLTools 설치 시 0xc000007b 실행오류가 나오는 경우 해결법을 서술하였다. SQLTools 다운로드 경로http://www.sqltools.net/ 설치한 Oracle 버전에 맞는 Instant Client (Oracle Call Interface) 파일을 받아야한다.https://www.oracle.com/database/technologies/instant-client/microsoft-windows-32-downloads.html 시스템 환경변수 Path에 해당 인터페이스의 압축을 푼 경로(C:\\instantclient_19_3)를 설정한다 여기까지 할 경우 툴의 실행 자체는 문제 없어진다. 이후의 설정은 TNS 셋팅(tnsnames.ora)을 불러오고 클라이언트의 언어 설정을 위한 것이다 시스템 환경변수에 아래 내용을 추가한다. ORACLE_HOME = C:\\instantclient_19_3 TNS_ADMIN = C:\\oraclexe\\app\\oracle\\product\\11.2.0\\server\\network\\ADMIN(tnsnames.ora 파일이 위치해 있는 디렉토리) NLS_LANG = AMERICAN_AMERICA.US7ASCII (DB 서버의 캐릭터셋과 일치시킨다) 출처 : http://m.blog.naver.com/ehcibear314/220271947239http://epr.pe.kr/wordpress/?p=451 추가만약 SQLTools 대신 SQL Developer를 사용하여 Oracle에 연결할 경우, 캐릭터셋 설정에 어려움이 있다.DB 서버와 클라이언트의 캐릭터셋을 모두 US7ASCII로 맞춰주어도 한글이 깨지는 문제가 발생한다.레지스트리, 환경변수 모두 제대로 셋팅해 주었으나 SQL Developer 자체적인 셋팅이 별도로 존재(놀랍게도 인코딩 셋팅 / NLS 셋팅이 툴 내에 별개로 있다..)하기 때문에 어떤 조합으로 셋팅을 하더라도 문제가 해결되지 않았다.그러니까 마음 편하게 SQLTools 쓰자","link":"/2019/07/30/Database/190716 - Oracle - SQLTools/"},{"title":"Sort Algorithm - Exchange Sort","text":"1. 교환정렬 (Exchange Sort)Algorithm : O(n^2)12345678910void exchangeSort(int n, keytype S[]){ index i, j; for (i = 1; i &lt; n; i++){ for (j = i+1; j &lt;= n; j++){ if (S[j] &lt; S[i]){ exchange S[i] and S[j]; } } }} 우선 첫 인덱스에 비교 지점(i)_을 고정해 놓고 끝까지 탐색(j++)_해가며 계속 교환한다. 루프_(for-i)_가 한 번 수행될 때마다 앞 인덱스부터 최소 값이 오게된다. 레벨-2 의 “b &lt; a” 노드는 우측 자식을 갖지 않도록 해야 한다. 앞서 루트에서 이미 해당 연산의 결과를 보였기 때문에, 우측 자식이 있는 경우는 모순인 것이다. 이처럼 가지치기를 해주어야 한다. 우리는 이 점에서 “b &lt; a” 연산이 두 번 시행되었다는 사실을 알 수 있다. SubOptimal한 알고리즘의 경우에는 “b &lt; a”가 참이라는 사실을 알 지 못하므로 이와같은 불필요한 연산이 추가로 수행된다. Every-case Time Complexity 값을 비교함으로써 정렬을 수행하는 알고리즘이므로, 두 숫자 사이의 값 비교 연산이 Basic Operation이 된다. 정렬할 항목의 수가 n이 된다 첫 번째 (for-i) 루프에서는 n-1번(2..n) 의 (for-j) 루프를 수행하고, 두 번째 (for-i) 루프에서는 n-2번_(3..n)_의 (for-j) 루프를 수행한다. 이 처럼 for-j 루프의 수행 횟수는 1씩 줄어든다. 이를 모두 더한 것이 시간복잡도가 된다. 교환 정렬은 항상 위의 모든 연산을 수행하므로, Every-Case Time Complexity는 (n-1)n / 2이다. 즉, O(n^2)이라고 할 수 있다.","link":"/2019/07/10/Algorithms/190710 - Sort-Algorithm-Exchange-Sort/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/10/ETC/190710 - hello-world/"},{"title":"Frontend Levels","text":"깃랩에서 올라온 공고가 Junior / Intermediate / Senior 레벨을 너무 잘 설명하고 있어 기억해두기 위해 가져왔습니다. 출처 : https://about.gitlab.com/jobs/apply/frontend-engineer-hiring-for-multiple-teams-4224948002/ Junior Frontend Engineer Technical Skills 모듈화되고 유지보수가 가능한 코드의 작성에 가이드가 필요함 HTML, CSS, JavaScript 경험이 적음 Needs guidance writing modular and maintainable code Has less experience with HTML, CSS &amp; JavaScript Code quality 이전보다 나은 형태의 코드를 유지 버그나 회귀의 수정 요청이 필요함 Leaves code in substantially better shape than before Needs prompting to fix bugs/regressions Communication 시간을 효율적으로 관리하는데 도움이 필요함 프론트엔드의 기술적 대화에 참여할 수 있음 Needs help to manage time effectively Participates in frontend technical conversations Performance &amp; Scalability 생산 가능한 코드의 작성에 도움이 필요함 대규모 앱의 개발 경험이 거의 없음 Needs help writing production-ready code Has little to no experience writing large scale apps Intermediate Frontend Engineer Technical Skills 모듈화되고 테스트된, 유지보수가 가능한 코드를 작성하기 위해 최소한의 가이드가 필요함 Needs minimal guidance to write modular, well-tested, and maintainable code Leadership 새로운 아이디어를 제안할 수 있으며, 그타당성을 분석하고 업무의 범위를 설정하기 위해 가이드가 필요함 중간 규모의 기능 개발 및 버그 수정, 제한된 가이드 만으로도 통합을 이끌 수 있음 (아키텍처 관점을 갖기 시작함) 주니어 개발자의 멘토링, 개발프로세스와 문서화 및 테스트 개선 등을 통해 팀원 전체가 생산성을 높일 수 있도록 노력함 Propose new ideas, needs guidance in performing feasibility analyses and scoping the work Capable of leading medium sized features, bug fixes, and integrations with limited guidance from leads or seniors (Eg. Begin to show architectural perspective) Should be striving to make the entire team more productive through their efforts. This might be through mentoring junior developers, or by improving the team’s process, documentation, testing or tooling in a way that helps everyone in the team be more effective. Code quality 이전보다 나은 형태의 코드를 유지 (이전보다 더 나은 상태의 테스트 : 더 빠르고, 안정적이며, 포괄적인 등) 복잡성을 최대한 줄이기 위해 노력함 : 기능이 복잡할 경우 어쩔 수 없는 경우를 제외하고 복잡성을 줄이거나 완화시킴 팀의 요청 없이도 버그와 회귀를 고침 전반적인 코드의 품질과 빌드 실패에 대해 모니터링함 Leave code in better shape than before (Eg. Leave tests in better shape than before: faster, more reliable, more comprehensive, etc.) Strive to reduce complexity contained as much as possible: if a feature is complex, that’s sometimes unavoidable, but Intermediate Developers show that they can reduce or mitigate complexity in their changes Fix bugs/regressions without much prompting from team Monitor overall code quality/build failures Communication 동료들에게 시기적절한 코드 피드백을 주며, 추후의 리뷰 / 유지관리를 위해 최소한의 작업만 남김 기술적 주제에 대해 소통하며 팀에게 아이디어를 제시할 수 있음 필요할 때 다른 이들에게 가이드를 요청하는데 적극적인 자세 진행상태를 최신 상황으로 유지 Provide thorough and timely code feedback for peers, generally leaving minimal work for later reviews / maintainers Able to communicate on technical topics and present ideas to the rest of the team Proactive in asking for guidance from others when needed Keep issues up-to-date with progress Performance &amp; Scalabilty 최소한의 보조로 생산 가능한 코드 작성 기존 툴을 이용하여 최소한의 가이드로 GitLab.com의 성능 문제를 해결하고 개선이 필요한 부분을 찾아낼 줄 앎 Writes production-ready code with minimal assistance Fixes performance issues on GitLab.com with minimal guidance using our existing tools, and identify areas of improvements where needed Senior Frontend Engineer Technical Skills 모듈화되고 테스트된, 유지보수 가능한 코드를 작성할 수 있음 Write modular, well-tested, and maintainable code Leadership 타당성을 분석하며 업무 영역을 설정할 수 있는 새로운 아이디어를 제시함 복잡한 기능 개발 및 버그 수정, 제한된 가이드 만으로도 통합을 이끌 능력이 있음 팀 전체의 생산성을 높일 수 있음. Propose new ideas, performing feasibility analyses and scoping the work Capable of leading complicated features, bug fixes, and integrations with limited guidance from leads (Eg. Begin to show architectural perspective) Should make the entire team more productive through their efforts. This might be through mentoring junior developers, or by improving the team’s process, documentation, testing or tooling in a way that helps everyone in the team be more effective. Code quality 코드를 이전보다 더 나은 형태로 유지함 (가능한 한 복잡성을 억제하고 이전보다 더 나은 형태로 테스트를 유지함) 버그와 회귀를 신속하게 해결함 전반적 코드 품질 / 빌드 실패를 모니터링함 Leave code in substantially better shape than before (Eg. Keep complexity contained as much as possible, Leave tests in better shape than before) Fix bugs/regressions quickly Monitor overall code quality/build failures Communication 동료들에게 시기적절한 코드 피드백을 주며, 추후의 리뷰 / 유지관리를 위해 최소한의 작업만 남김 기술적 주제에 대해 명확히 소통할 줄 알며, 팀원들에게 아이디어를 제시할 수 있음 진행상태를 최신 상황으로 유지 Provide thorough and timely code feedback for peers, leaving minimal work for later reviews / maintainers Able to communicate clearly on technical topics and present ideas to the rest of the team Keep issues up-to-date with progress Performance &amp; Scalability 약간의 보조로 생산 가능한 코드 작성에 탁월함 기존 툴을 이용하여 최소한의 가이드로 GitLab.com의 성능 문제를 해결하고, 필요하다면 기존 툴을 개선시킬 수 있음 Excellent at writing production-ready code with little assistance Are able to fix performance issues on GitLab.com with minimal guidance using our existing tools, and improve those tools where needed","link":"/2019/07/29/Web/190729 - Frontend Levels/"},{"title":"작성중) Session / Session Clustering","text":"Session is짧게 얘기하자면, 세션이란 어떠한 연결이 이루어진 후 끊어지기 전까지의 상태를 의미한다. 이 세션에는 사용자와 관련된 여러가지 정보들이 저장될 수 있다.","link":"/2019/07/30/Web/190730 - Session/"},{"title":"Oracle - DDL","text":"제약 조건 COLUMN_CONSTRAINT TABLE_CONSTRAINT CONSTRAINT 이름은 보통 tableName[_columnName]_constraintName 형태로 관리한다 NOT NULL과 UNIQUE를 조합해서 PK, FK를 만들 수 있다. CHECK 제약 조건을 주어 값을 검사할 수도 있다. CREATE테이블 이름 테이블 이름은 문자로 시작되어야 한다. 30자까지 가능하고, 한글도 된다. 객체로 관리되기 때문에 중복이 불가능하다. 데이터 타입 문자형 DATA TYPE을 사용할 때, 한글은 3바이트임을 명심하고 설계하자. 데이터는 대소문자를 구분해야 한다. 기타 현장에서 우리가 볼 수 있는건 ERD와 TABLE 명세 정도다. 1234567CREATE TABLE ORDERS( ORDERNO CHAR(4), CUSTNO CHAR(4), ORDERDATE DATE DEFAULT SYSDATE, SHIPDATE DATE, ...) NUMBER 형은 사이즈를 지정하지 않는다면 가변형이 된다. DEFAULT 옵션을 줄 수 도 있다. 12345678910111213CREATE TABLE TABLE_NOTNULL( ID CHAR(3) NOT NULL, SNAME VARCHAR2(20));CREATE TABLE TABLE_NOTNULL2( ID CHAR(3), SNAME VARCHAR2(20), CONSTRAINT TN2_ID_NN NOT NULL (ID));ORA-00904: : invalid identifier NOT NULL 제약조건은 COLUMN LEVEL에서만 사용이 가능하다. (TABLE LEVEL은 불가능하다!) 12345678INSERT INTO TABLE_NOTNULLVALUES ('100', 'ORACLE');INSERT INTO TABLE_NOTNULLVALUES (NULL, 'ORACLE'); ORA-01400: cannot insert NULL into (\"HR\".\"TABLE_NOTNULL\".\"ID\") (0 rows affected) 컬럼을 만들며 제약 조건을 만드는 방식이 있고 (COLUMN LEVEL) 컬럼을 다 열거한 후에 제약조건은 나열하는 방식이 있다. (TABLE LEVEL) 12INSERT INTO table_name VALUES(value [, value]);INSERT INTO table_name(column [, column]) VALUES(value [, value] [, DEFAULT]); column과 value의 데이터 갯수, 데이터 타입이 일치하지 않는다면 error! DEFAULT로 설정된 COLUMN은 반드시 바뀌어선 안되는 값이어야 한다. 123456789101112131415161718CREATE TABLE TABLE_UNIQUE2 ( ID CHAR(3), SNAME VARCHAR2(20), SCODE CHAR(2), CONSTRAINT TN2_ID_UN UNIQUE (ID, SNAME) ) INSERT INTO TABLE_UNIQUE2 VALUES ('100', 'ORACLE', '01');INSERT INTO TABLE_UNIQUE2VALUES ('200', 'ORACLE', '01');INSERT INTO TABLE_UNIQUE2VALUES ('200', 'ORACLE', '02');ORA-00001: unique constraint (HR.TN2_ID_UN) violated (0 rows affected) UNIQUE 제약은 COLUMN을 조합해서 사용할 수도 있다. UNIQUE는 내부적으로 INDEX로 관리가 된다. SORTING 해서 객체로 만들어져서 관리가 되고 있는 것이다. PK도 기본적으로 UNIQUE가 걸리는 것 -INDEX가 별도로 하나 만들어 지는 것. 해당 COLUMN이 WHERE 절에 활용된다면 FULL TABLE SCAN을 막을 수 있다. 그러나, 무분별하게 UNIQUE를 사용한다는 것은 인덱스가 많아진다는 것을 의미하게 된다. 123456789101112131415161718CREATE TABLE TABLE_PK2 ( ID CHAR(3), SNAME VARCHAR2(20), SCODE CHAR(2), CONSTRAINT TP2_PK PRIMARY KEY (ID, SNAME) );INSERT INTO TABLE_PK2VALUES ('100', 'ORACLE', '02');INSERT INTO TABLE_PK2VALUES ('100', 'ORACLE', '01'); ORA-00001: unique constraint (HR.TP2_PK) violated (0 rows affected) PK = NOT NULL + UNIQUE PK는 보통 composite key를 사용하지 않는다. COMPOSITE PK라면 TABLE LEVEL의 제약조건으로 서술해야 한다. 같은 테이블에서 두개의(COMPOSITE) FK를 받아오게 된다면 그것 또한 TABLE LEVEL로 구성해야 한다. COMPOSITE을 그대로 이어받는 개념 개념적 모델링 -&gt; 논리 모델링 개념적 모델링에서는 관계형 DB 이론이 들어가서는 안된다.(다대다 관계 가능) 관계형 DB 이론은 논리 모델링에서 생각된다.(RDB에서 다대다 관계를 풀어야 한다.) 교차실제를 사용해서 테이블을 구성한다. (해당 테이블에서의 각 키는 외래키이면서 기본키가 된다.) -composite PK를 사용하게 된다. 123456789101112CREATE TABLE TABLE_FK ( ID CHAR(3), SNAME VARCHAR(20), LID CHAR(2) REFERENCES LOCATION ( LOCATION_ID ) );INSERT INTO TABLE_FKVALUES ('200', 'ORACLE', 'C1');ORA-02291: integrity constraint (HR.SYS_C007062) violated - parent key not found (0 rows affected) 상황에 따라서 PK가 아닌 UNIQUE를 사용하기도 한다 column_name을 명시하지 않아도 알아서 PK / UNIQUE KEY를 찾는다 상황에 따라서는 테스트를 위해 관계를 끊어놓고 테스트 후 다시 관계를 생성하기도 한다. 1ON DELETE SET NULL 부모가 지워질 때 NULL로 값을 바꿈 1ON DELETE CASCADE 부모가 지워질 때 같이 지움 위의 두 설정은 매우 위험하다는 것을 명심하자 12345678910111213141516171819CREATE TABLE TABLE_CHECK ( EMP_ID CHAR(3) PRIMARY KEY, SALARY NUMBER CHECK ( SALARY 0 ), MARRIAGE CHAR(1), CONSTRAINT CHK_MRG CHECK ( MARRIAGE IN ( 'Y', 'N') ) );INSERT INTO TABLE_CHECKVALUES ('100', -100, 'Y');ORA-02290: check constraint (HR.SYS_C007064) violated (0 rows affected)INSERT INTO TABLE_CHECKVALUES ('100', 500, '?');ORA-02290: check constraint (HR.CHK_MRG) violated (0 rows affected)INSERT INTO TABLE_CHECKVALUES ('100', 500, 'y');ORA-02290: check constraint (HR.CHK_MRG) violated (0 rows affected) 데이터 조건은 대소문자를 구분한다 CHECK 제약 조건은 바뀌는 값을 기준으로 두면 안된다! 123456789101112CREATE TABLE TABLE_SUBQUERY1 AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE FROM EMPLOYEE LEFT JOIN DEPARTMENT USING (DEPT_ID) LEFT JOIN JOB USING (JOB_ID);SELECT *FROM TABLE_SUBQUERY1; 서브쿼리를 활용하여 테이블을 생성 할 수 있다. 내부에서 미리 별칭을 지정하고 리턴 받을 수 있다. CREATE 시점의 AS 키워드는 생략이 불가능하다. (데이터를 받아오려고 할 때) COLUMN의 DATA TYPE을 따로 지정할 수 없다. 컬럼 이름은 서브쿼리에서 사용한 이름 그대로 사용하여 생략이 가능하다 NOT NULL 제약조건은 자동으로 반영된다. (TABLE LEVEL의 제약조건은 ALTER를 사용해서 추가한다) 그 외의 제약조건은 생성 시점에 컬럼 레벨에서만 가능하다 (REFERENCES 제약조건은 불가능하다) 그러나 메모리의 가용성을 생각한다면 테이블(물리적 구조)보다 뷰를 만드는 것이 나을 것이다. 뷰는 논리적 구조를 갖고 있다. (휘발성이다) 123456789ALTER TABLE table_name RENAME TO new_table_nameALTER TABLE table_name RENAME [COLUMN column_name] TO new_column_nameCREATE TABLE EMP3 AS SELECT * FROM EMPLOYEE;ALTER TABLE EMP3ADD PRIMARY KEY (EMP_ID)ADD UNIQUE (EMP_NO)MODIFY HIRE_DATE NOT NULL; 테이블 이름, 컬럼 이름, 제약조건 이름을 ALTER .. RENAME 키워드로 수정할 수 있다. 컬럼의 타입이나 DEFAULT, NOT NULL을 NULL로 바꿔주어야 할 경우만 ALTER .. MODIFY 키워드를 사용하면 된다. 컬럼을 추가하고 싶다면 ALTER .. ADD 키워드 컬럼 / 테이블 삭제 : DROP 레코드 삭제 : DELETE COLUMN을 DROP 하고 싶더라도 혹시 모르니 DISABLE 시켜놓고 사용하는 경우가 많다. 뷰 (VIEW)1CREATE [OR REPLACE] VIEW view_name ... AS subquery ORACLE에서는 뷰를 하나의 객체(OBJECT)로 본다. stored query / virtual table이라고도 불린다. 부분집합을 통한 선택적 정보를 얻고 싶을 때 뷰를 사용한다. 복잡한 SQL 구문을 단순화 시킨다. 보안과 관련된 부분에도 사용한다. (복합)뷰에는 조작(INSERT / DELETE/ UPDATE)이 불가능하다. (단일 테이블 뷰는 조작이 가능하다.) 복합뷰라고 하더라도 트리거를 만들어서 PL/SQL을 이용하면 가능은 하다. 뷰의 목적 자체는 읽기 전용이라는 것을 기억하자. 123456789101112131415161718192021222324252627CREATE OR REPLACE VIEW V_EMP_DEPT_JOB(ENM, DNM, TITLE)AS SELECT EMP_NAME, DEPT_NAME, JOB_TITLE FROM EMPLOYEE LEFT JOIN DEPARTMENT USING (DEPT_ID) LEFT JOIN JOB USING (JOB_ID) WHERE JOB_TITLE = '사원';CREATE OR REPLACE VIEW V_EMP_DEPT_JOBAS SELECT EMP_NAME AS ENM, DEPT_NAME AS DNM, JOB_TITLE AS TITLE FROM EMPLOYEE LEFT JOIN DEPARTMENT USING (DEPT_ID) LEFT JOIN JOB USING (JOB_ID) WHERE JOB_TITLE = '사원';SELECT *FROM V_EMP_DEPT_JOB;SELECT ENM, TITLEFROM V_EMP_DEPT_JOB; 뷰에도 각 컬럼 이름에 별칭을 두가지 방법으로 줄 수 있다. CREATE OR REPLACE로 묶어서 생각하자 뷰를 사용하지 않을 것이라면 DROP VIEW view_name을 하면 된다. 함수와 같이 특수문자가 사용된 컬럼에 별칭을 주지 않으면 오류가 발생한다. 12345678910111213141516171819202122232425CREATE OR REPLACE VIEW V_DEPT_SALAVG (\"Did\", \"Davg\")AS SELECT NVL(DEPT_ID, 'N/A'), ROUND(AVG(SALARY), -3) FROM EMPLOYEE GROUP BY DEPT_ID;SELECT EMP_NAME, SALARYFROM EMPLOYEE JOIN V_DEPT_SALAVG ON ( NVL(DEPT_ID, 'N/A') = \"Did\" )WHERE SALARY \"Davg\"ORDER BY 2 DESC;SELECT EMP_NAME, SALARYFROM (SELECT NVL(DEPT_ID, 'N/A') AS \"Did\", ROUND(AVG(SALARY), -3) AS \"Davg\" FROM EMPLOYEE GROUP BY DEPT_ID) INLV JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV.\"Did\" )WHERE SALARY INLV.\"Davg\"ORDER BY 2 DESC; 뷰를 만드는 것과 인라인 뷰를 사용하는 것 모두 결과는 동일하다 TOP N 분석 최상의 N개를 뽑아오기 위한 것 -TOP N 분석 전제조건 : 인라인뷰가 정렬이 되어 있어야 함 (인라인뷰를 만들고) ROWNUM 컬럼을 이용하여 순번을 부여하여 검색 조건으로 활용 (ROWNUM을 사용하자!) ROWNUM 키워드는 최상위, 혹은 최상위로부터의 범위 식별만 가능하다. 1234567891011SELECT ROWNUM, EMP_NAME, SALARYFROM (SELECT NVL(DEPT_ID, 'N/A') AS \"Did\", ROUND(AVG(SALARY), -3) AS \"Davg\" FROM EMPLOYEE GROUP BY DEPT_ID) INLV JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV.\"Did\" )WHERE SALARY INLV.\"Davg\"ORDER BY 3 DESC; ORDER BY를 사용하니 ROWNUM 결과가 섞인것을 확인할 수 있다. -X 1234567891011SELECT ROWNUM, EMP_NAME, SALARYFROM (SELECT NVL(DEPT_ID, 'N/A') AS \"Did\", ROUND(AVG(SALARY), -3) AS \"Davg\" FROM EMPLOYEE GROUP BY DEPT_ID) INLV JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV.\"Did\" )WHERE SALARY INLV.\"Davg\" AND ROWNUM = 3; ROWNUM은 특정 순위만 뽑아서 볼 수 없다. -X 1234567891011SELECT ROWNUM, EMP_NAME, SALARYFROM (SELECT NVL(DEPT_ID, 'N/A') AS \"Did\", ROUND(AVG(SALARY), -3) AS \"Davg\" FROM EMPLOYEE GROUP BY DEPT_ID) INLV JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV.\"Did\" )WHERE SALARY INLV.\"Davg\" AND ROWNUM &lt;= 5; 범위를 뽑아서 N개의 레코드를 식별할 수는 있으나 정렬이 되어 있지는 않다. -X 12345678910111213SELECT EMP_NAME, SALARYFROM (SELECT EMP_NAME, SALARY FROM (SELECT NVL(DEPT_ID, 'N/A') AS \"Did\", ROUND(AVG(SALARY), -3) AS \"Davg\" FROM EMPLOYEE GROUP BY DEPT_ID) INLV JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV.\"Did\" ) WHERE SALARY INLV.\"Davg\" ORDER BY SALARY DESC)WHERE ROWNUM &lt;= 5; 이처럼 순번을 활용하려면 미리 정렬하고 인라인뷰를 사용해야 한다. 1234567891011121314151617SELECT EMP_NAME, SALARYFROM (SELECT EMP_NAME, SALARY, ROWNUM AS RN FROM (SELECT EMP_NAME, SALARY FROM (SELECT NVL(DEPT_ID, 'N/A') AS \"Did\", ROUND(AVG(SALARY), -3) AS \"Davg\" FROM EMPLOYEE GROUP BY DEPT_ID) INLV JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV.\"Did\" ) WHERE SALARY INLV.\"Davg\" ORDER BY SALARY DESC) WHERE ROWNUM &lt;= 5)WHERE RN = 5; 사원테이블에서 많은 급여를 받는 사원의 이름, 직급이름, 급여를 내림차순으로 출력하라 123456SELECT EMP_NAME, JOB_TITLE, SALARYFROM EMPLOYEE E JOIN JOB J USING (JOB_ID)ORDER BY SALARY DESC; 상위 5건만 끊어보기 12345678910111213141516171819SELECT EMP_NAME, JOB_TITLE, SALARYFROM (SELECT EMP_NAME, JOB_TITLE, SALARY FROM EMPLOYEE E JOIN JOB J USING (JOB_ID) ORDER BY SALARY DESC)WHERE ROWNUM &lt;= 5;SELECT *FROM (SELECT EMP_NAME, SALARY, RANK() OVER ( ORDER BY SALARY DESC) AS RANK FROM EMPLOYEE E)WHERE RANK &lt;= 5; 위와 같이 두가지 방법을 사용할 수 있다. 12345678SELECT *FROM (SELECT EMP_NAME, SALARY, RANK() OVER ( ORDER BY SALARY DESC) AS RANK FROM EMPLOYEE E)WHERE RANK = 5; ROWNUM의 단점인 특정 레코드 식별의 어려움을 RANK()로 극복할수 있다. 123SELECT RANK(2300000) WITHIN GROUP (ORDER BY SALARY DESC) AS RANKFROM EMPLOYEE; SALARY 값을 순서대로 정렬한 후 2300000은 몇번째 순위인지 반환 위와같이 RANK(..) WITHIN GROUP을 사용하면 된다 123456SELECT EMP_NAME, SALARY, RANK() OVER ( ORDER BY SALARY DESC) AS RANKFROM EMPLOYEE E; RANK() OVER .. 를 사용하여 전체 순번을 얻어올 수 있다. 시퀀스 (SEQUENCE) 중복되지 않는 번호를 무한대로 증가하며 매길 수 있다. (MAXVALUE와 CYCLE 설정을 하지 않을 경우) SEQUENCE는 기본키로도 많이 사용한다. 객체를 삭제할 때는 DELETE가 아닌 DROP 키워드를 사용한다. (SEQUENCE도 객체)","link":"/2019/07/16/Database/190716 - Oracle - DDL/"},{"title":"Oracle - SELECT","text":"기본 문법1234567891011SELECT *FROM EMPLOYEE;SELECT EMP_ID, EMP_NAMEFROM EMPLOYEE;SELECT EMP_NAME AS 이름, SALARY * 12 AS \"1년 급여\", ( SALARY + ( SALARY * BONUS_PCT ) ) * 12 AS 총소득FROM EMPLOYEE; nsl &lt;&lt; 데이트 포맷 형식 1234567SELECT EMP_ID AS \"empid\", EMP_ID AS \"EmPiD\", EMP_ID AS \"EMPID\", EMP_ID AS empid, EMP_NAME AS \"이름\", SALARY AS \"급여(원)\"FROM EMPLOYEE; 오라클에서 “” 는 문자열이 아님! 특수문자, 공백, “대소문자구분” 등 123SELECT EMP_NAME, SALARY AS 급여(원)FROM EMPLOYEE; 특수문자 ( ) 로 인해 에러 123SELECT EMP_NAME, SALARY AS 1달급여FROM EMPLOYEE; 숫자로 시작하기 때문에 에러 1234SELECT EMP_ID, EMP_NAME, '재직' AS 근무여부FROM EMPLOYEE; 더미 컬럼을 넣을 수도 있다. 123456SELECT DISTINCT DEPT_IDFROM EMPLOYEE;SELECT DISTINCT JOB_ID, DEPT_IDFROM EMPLOYEE; DISTINCT 키워드를 사용하여 조합된 unique 값을 구한다. (컬럼 단위 적용이 아니다) 123456789SELECT EMP_NAME AS 이름, DEPT_ID AS 부서FROM EMPLOYEEWHERE DEPT_ID = '90';SELECT EMP_NAME AS 이름, SALARY AS 부서FROM EMPLOYEEWHERE SALARY &gt; 400000; 문자열인 경우 ‘ ‘ 로 WHERE 조건을, 숫자의 경우 그대로 조건을 걸어주었다. 12345678910SELECT EMP_ID || EMP_NAME || SALARYFROM EMPLOYEE;SELECT EMP_NAME || '의 월급은' || SALARY || '원 입니다.'FROM EMPLOYEE; 칼럼의 값을 합칠 때는 || 를 이용해 연결하면 된다. 마찬가지로 표현식도 가능하다.오라클에서 리터럴은 값을 의미하기 때문에 ‘’를 사용한다. 12345678910SELECT EMP_NAME, SALARYFROM EMPLOYEEWHERE SALARY BETWEEN 3500000 AND 5500000;SELECT EMP_NAME, SALARYFROM EMPLOYEEWHERE SALARY &gt;= 3500000 AND SALARY &lt;= 5500000; BETWEEN AND 는 상한값과 하한값을 포함할 때만 사용하자. 12345678910111213SELECT EMP_NAME, MGR_ID, DEPT_IDFROM EMPLOYEEWHERE MGR_ID IS NULL AND DEPT_ID IS NULL;SELECT EMP_NAME, DEPT_ID, BONUS_PCTFROM EMPLOYEEWHERE DEPT_ID IS NULL AND BONUS_PCT IS NOT NULL; NULL 값의 체크는 IS NULL과 IS NOT NULL로 한다. 1234SELECT EMP_NAME, SALARYFROM EMPLOYEEWHERE EMP_NAME LIKE '김%'; % 는 0개 이상의 문자, . 은 단 1개의 문자를 의미한다 1234567891011121314SELECT EMP_NAME, EMAILFROM EMPLOYEEWHERE EMAIL LIKE '____%';SELECT EMP_NAME, EMAILFROM EMPLOYEEWHERE EMAIL LIKE '___\\_%' ESCAPE '\\';SELECT EMP_NAME, EMAILFROM EMPLOYEEWHERE EMAIL LIKE '___#_%' ESCAPE '#'; ESCAPE 키워드로 문자를 지정할 수 있다.NOT 은 NOT 컬럼 LIKE 혹은 NOT LIKE의 형태로 쓴다. 123456789101112SELECT EMP_NAME, DEPT_ID, SALARYFROM EMPLOYEEWHERE DEPT_ID IN ( '60', '90' );SELECT EMP_NAME, DEPT_ID, SALARYFROM EMPLOYEEWHERE DEPT_ID = '60' OR DEPT_ID = '90'; 같은 컬럼에 대한 조건은 IN 키워드로 사용할 수도 있다. 123456789101112131415SELECT EMP_NAME, SALARY, DEPT_IDFROM EMPLOYEEWHERE DEPT_ID = '20' OR DEPT_ID = '90' AND SALARY &gt; 3000000;SELECT EMP_NAME, SALARY, DEPT_IDFROM EMPLOYEEWHERE ( DEPT_ID = '20' OR DEPT_ID = '90' ) AND SALARY &gt; 3000000; 연산자 우선순위로 인한 혼동을 피하기 위해서 ()를 적극적으로 사용하자. 123456SELECT *FROM COLUMN_LENGTH;SELECT LENGTH(CHARTYPE), LENGTH(VARCHARTYPE)FROM COLUMN_LENGTH; CHAR TYPE에 한글이 들어갈 경우 길이 LENGTH() 길이 계산 = 문자열 수 + 여유 공간 바이트 1234567891011121314SELECT EMAIL, INSTR(EMAIL, 'c', -1, 2) 위치FROM EMPLOYEE;SELECT EMAIL, INSTR(EMAIL, 'c', INSTR(EMAIL, '.') - 1 - LENGTH(EMAIL)) 위치FROM EMPLOYEE;SELECT *FROM EMPLOYEE;SELECT EMAIL, INSTR(EMAIL, 's', 0) 위치FROM EMPLOYEE; INSTR() 을 통해 부분 문자열의 시작 위치 INDEX를 얻어올 수 있다. 12345SELECT SUBSTR('THIS IS A TEST', 6, 2)FROM DUAL;SELECT SUBSTR('TECHONTHENET', -3, 20)FROM DUAL; SUBSTR() 을 통해 부분 문자열을 잘라올 수 있다.시작 위치를 음수 값(-3)으로 주더라도 오른쪽으로 잘라온다. 123456SELECT *FROM EMPLOYEE;SELECT EMAIL, SUBSTR(EMAIL, 1, INSTR(EMAIL, '@') - 1) IDFROM EMPLOYEE; 사원 테이블에서 메일 아이디만 출력하기. 12345SELECT LTRIM(' TE CH', ' ')FROM DUAL;SELECT LTRIM('123321TECH123', '123')FROM DUAL; LPAD(), LTRIM() 등의 함수로 문자열을 추가 / 잘라내기 할 수 있다.LTRIM(), RTRIM()을 사용할 때는 패턴 매칭이 아닌 각각의 문자 매칭이다. 문자열 함수 : LENGTH(), INSTR(), SUBSTR(), LPAD(), TRIM() 등등.. 1234567891011SELECT ROUND(125.315)FROM DUAL;SELECT ROUND(125.315, 1)FROM DUAL;SELECT ROUND(125.315, -1)FROM DUAL;SELECT ROUND(-125.315, 2)FROM DUAL; 계산의 편의를 위해 (비교를 위해)실제 현장에서는 소숫점도 중요하므로 반올림 하지 않는 경우가 많음 숫자 함수 : ROUND(), TRUNC() SYSDATE소괄호가 없는 키워드 형식의 함수 SYSDATE -&gt; DATE 형식의 값 리턴NSL_DATE_FORMAT에 따라서, DBMS 버전에 따라서, 개발 툴에 따라서 표현되는 날짜 형식이 다름기본 오라클 포맷은 YY/MM/DD 이지만 포맷 설정에 따라 달라짐 (DATE 형식에는 연월일 시분초가 들어가 있음) ADD_MONTHS()DATE 형식도 연산이 가능. (+1 -&gt; 1일 증가) 1234SELECT EMP_NAME, HIRE_DATE, ADD_MONTHS(HIRE_DATE, 240) AS \"20년 근속 시\"FROM EMPLOYEE; 개월 수를 더하기 위해서는 ADD_MONTHS()를 사용. MONTHS_BETWEEN()– 두 날짜사이의 개월 수를 (NUMBER 타입으로) 리턴 받음– DATE1 &gt; DATE2 : 양수 반환– DATE2 &lt; DATE1 : 음수 반환 12345SELECT EMP_NAME, HIRE_DATE, TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE) / 12) AS 근무년수FROM EMPLOYEEWHERE MONTHS_BETWEEN(SYSDATE, HIRE_DATE) &gt; 120; 입사한 지 10년이 넘은 직원들의 근무년수 날짜 함수 : SYSDATE, ADD_MONTHS(), MONTHS_BETWEEN(date1, date2) Implicit Type Casting, Explicit Type Casting.NUMBER를 직접적으로 DATE로 바꿀수는 없다. 중첩을 이용해서 바꾸어야 함 TO_DATE( TO_CHAR( NUMBER ) )Type 변환 함수는 SQL 성능에 영향을 미치므로 잘 알고 사용해야 한다리터럴 값에 변환함수를 쓰는 것은 괜찮으나, 컬럼에 변환함수를 쓰면 인덱싱이 되지 않으므로 문제가 됨 12SELECT TO_CHAR(1234, 'L99,999')FROM DUAL; TO_CHAR(), TO_DATE(), TO_NUMBER() 1234567SELECT TO_CHAR(SYSDATE, 'PM HH24:MI:SS'), TO_CHAR(SYSDATE, 'AM HH:MI:SS'), TO_CHAR(SYSDATE, 'MON DY, YYYY'), TO_CHAR(SYSDATE, 'YYYY-fmMM-DD DAY'), TO_CHAR(SYSDATE, 'YYYY-MM,fmDD DAY'), TO_CHAR(SYSDATE, 'Year, Q')FROM DUAL; DATE 포맷을 출력하는 방식은 다양하게 줄 수 있다 12345678910111213141516171819SELECT EMP_NAME AS 이름, TO_CHAR(HIRE_DATE, 'YYYY-MM-DD') AS 입사일FROM EMPLOYEEWHERE JOB_ID = 'J7';SELECT EMP_NAME AS 이름, TO_CHAR(HIRE_DATE, 'YYYY\"년\" MM\"월\" DD\"일\"') AS 입사일FROM EMPLOYEEWHERE JOB_ID = 'J7';SELECT EMP_NAME AS 이름, SUBSTR(HIRE_DATE, 1, 2) ||'년 ' || SUBSTR(HIRE_DATE, 4, 2) ||'월 ' || SUBSTR(HIRE_DATE, 7, 2) ||'일' AS 입사일FROM EMPLOYEEWHERE JOB_ID = 'J7'; 표현에 따라 SUBSTR를 사용할 수도 있다. 123456789101112131415161718192021222324SELECT TO_DATE('20100101', 'YYYYMMDD')FROM DUAL;SELECT TO_CHAR('20100101', 'YYYY, MON')FROM DUAL; -- 에러!SELECT TO_CHAR(TO_DATE('20100101', 'YYYYMMDD'), 'YYYY, MON')FROM DUAL;SELECT TO_DATE ('041030 143000', 'YYMMDD HH24MISS')FROM DUAL;SELECT TO_CHAR(TO_DATE('041030 143000', 'YYMMDD HH24MISS'), 'DD-MM-YY HH:MI:SS PM')FROM DUAL;SELECT TO_DATE ('930630', 'YYMMDD')FROM DUAL;SELECT TO_CHAR (TO_DATE('980630', 'YYMMDD'), 'YYYY.MM.DD')FROM DUAL; -- 2098.06.30SELECT TO_CHAR (TO_DATE('980630', 'RRMMDD'), 'YYYY.MM.DD')FROM DUAL; -- 1998.06.30 RR 키워드는 지정한 년도와 현재 년도를 비교해여 세기를 결정짓는다세기를 맞추기 위해 RR 형식을 사용하면 된다 -&gt; BUT, 정확하게 하기 위해서는 YYYY를 사용하는게 좋다. 12SELECT TO_CHAR (TO_DATE('980630', 'YYMMDD'), 'RRRR.MM.DD')FROM DUAL; -- 2098.06.30 CHAR -&gt; TO_DATE() -&gt; TO_CHAR() 에서 RR 키워드는 TO_DATE() 안에서 사용해야 한다!TO_CHAR() 안에서는 이미 TO_DATE()로 1998년이 되었기 때문에 2098로 나온다! TO_DATE()는 앞의 문자열을 뒤의 포맷으로 맞춰주는 것일 뿐이다DATE 포맷에는 연월일 시분초가 다 포함된다.기본적으로 SYSDATE를 사용하면 시분초가 0으로 들어가 있어 주의해야 한다.따라서 데이터가 시분초를 가지고 있다면, 연월일 조건만으로는 꺼내올 수 없다.그러한 경우에는 CHAR 형태로 변환하여 비교해 꺼내온다 TO_NUMBER()는 문자열 정수만 가능하다 12345678910111213141516SELECT EMP_NAME, EMP_NO, SUBSTR(EMP_NO, 1, 6) AS 앞부분, SUBSTR(EMP_NO, 8) AS 뒷부분, TO_NUMBER( SUBSTR(EMP_NO, 1, 6) ) + TO_NUMBER( SUBSTR(EMP_NO, 8) ) AS 결과FROM EMPLOYEEWHERE EMP_ID = '101';SELECT EMP_NAME, EMP_NO, SUBSTR(EMP_NO, 1, 6) AS 앞부분, SUBSTR(EMP_NO, 8) AS 뒷부분, SUBSTR(EMP_NO, 1, 6) + SUBSTR(EMP_NO, 8) AS 결과FROM EMPLOYEEWHERE EMP_ID = '101'; ORACLE에서는 문자열 간 + 연산이 없다.즉, TO_NUMBER()가 없어도 사용했을 때와 동일한 결과가 나온다 (implicit casting으로 인해) 12345678910SELECT EMP_NAME, SALARY, NVL(BONUS_PCT, 0)FROM EMPLOYEEWHERE SALARY &gt; 3500000;SELECT EMP_NAME, ( SALARY * 12 ) + ( ( SALARY * 12 ) * NVL(BONUS_PCT, 0) )FROM EMPLOYEEWHERE SALARY &gt; 3500000; NVL()을 사용하여 NULL을 체크한다.QUERY를 작성하기 전에 데이터의 유형을 충분히 파악하고 작성하는 것이 좋다.특정한 COLUMN 값을 산술 연산에 포함 시킬 때 반드시 NULL 여부를 체크하자 1234567891011121314SELECT EMP_NAME, DECODE(SUBSTR(EMP_NO, INSTR(EMP_NO, '-', 1) + 1, 1), 1, '남성', 2, '여성') AS 성별FROM EMPLOYEE;SELECT EMP_NAME AS 이름, SALARY AS 급여, JOB_ID AS 직급, SALARY * DECODE(JOB_ID, 'J7', 1.1, 'J6', 1.15, 'J5', 1.2, 1) AS 인상급여FROM EMPLOYEE; IF-ELSE 논리를 제한적으로 구현한 함수로 DECODE()가 있다.DECODE() 로도 NULL 조건을 체크할 수 있다 -&gt; 즉, NVL()로 대체가 가능하다. 12345678910111213141516171819CASE expr WHEN search THEN result [WHEN .. THEN ..] [ELSE default] ENDCASE WHEN condition1 THEN result1 [WHEN .. THEN ..] [ELSE default] ENDSELECT EMP_NAME, CASE ( SUBSTR(EMP_NO, INSTR(EMP_NO, '-', 1) + 1, 1) ) WHEN TO_CHAR(1) THEN '남성' ELSE '여성' ENDFROM EMPLOYEE;SELECT EMP_ID 아이디, EMP_NAME 이름, SALARY 급여, CASE WHEN SALARY &lt;= 3000000 THEN '초급' WHEN SALARY &lt;= 4000000 THEN '중급' ELSE '고급' END AS \"급여 등급\"FROM EMPLOYEE; DECODE()는 오라클 지정함수. ANSI 표준에는 CASE()가 있음. – SUM() 안에는 논리적인 표현식 모두 올 수 있다. DISTINCT, CASE 모두 가능하다– 그룹함수 : SUM(), AVG(), MIN(), MAX(), COUNT() 1234567891011121314SELECT DEPT_ID AS 부서, ROUND(AVG(SALARY), -4) AS 평균급여FROM EMPLOYEEGROUP BY DEPT_IDORDER BY 1;SELECT DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') AS 성별, ROUND(AVG(SALARY), -4) AS 평균급여FROM EMPLOYEEGROUP BY DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여'); SELECT 절에 GROUP FUNCTION이 온다면 일반 COLUMN은 올 수 없다GROUP BY도 COMPOSITE 하여 사용 할 수 있다. 12345678910111213141516171819202122232425SELECT DEPT_ID, SUM(SALARY)FROM EMPLOYEEWHERE DEPT_ID IS NOT NULLGROUP BY ROLLUP( DEPT_ID );SELECT DEPT_ID, JOB_ID, SUM(SALARY)FROM EMPLOYEEWHERE DEPT_ID IS NOT NULL AND JOB_ID IS NOT NULLGROUP BY ROLLUP( DEPT_ID, JOB_ID )ORDER BY DEPT_ID, JOB_ID;SELECT DEPT_ID, JOB_ID, SUM(SALARY)FROM EMPLOYEEWHERE DEPT_ID IS NOT NULL AND JOB_ID IS NOT NULLGROUP BY ROLLUP( DEPT_ID, JOB_ID )ORDER BY DEPT_ID, JOB_ID; 총계를 확인하기 위해 ROLLUP()을 사용한다 123456789101112SELECT DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME, EMP_NAMEFROM DEPARTMENTJOIN LOCATIONON ( LOC_ID = LOCATION_ID)JOIN COUNTRYUSING (COUNTRY_ID)JOIN EMPLOYEEUSING (DEPT_ID); JOIN 하려는 테이블 간 컬럼 명이 다를 경우 ON을 사용한다.USING에서는 ALIAS 를 사용할 수 없으나, ON에서는 사용 할 수 있다.ON과 USING을 혼합해서 사용 할 수 있다. 12345678910111213141516SELECT EMP_NAME, SALARY, SLEVELFROM SAL_GRADE SJOIN EMPLOYEE EON ( LOWEST &lt;= SALARY AND SALARY &lt;= HIGHEST)SELECT EMP_NAME, SALARY, SLEVELFROM SAL_GRADE SJOIN EMPLOYEE EON ( SALARY BETWEEN LOWEST AND HIGHEST)ORDER BY SLEVEL; JOIN은 반드시 업무적 연관관계가 있는 테이블 사이에서만 이루어지는 것이 아니다.ON 구문에서는 비교식을 사용할 수 있다 -&gt; AND / OR 도 사용이 가능하다! NATURAL [INNER] JOIN은 키를 명시하지 않고 알아서 INNER JOIN을 수행한다.그 전제조건으로는 컬럼의 이름이 동일해야 한다는 것이 있다. (PK = FK) OUTER JOIN도 USING과 ON을 기반으로 한다.INNER JOIN에서 INNER 키워드를 생략할 수 있었던 것처럼,LEFT|RIGHT|FULL OUTER JOIN 에서도 OUTER 키워드를 생략할 수 있다. 123456789SELECT EMP_NAME, DEPT_NAMEFROM EMPLOYEE E, DEPARTMENT DWHERE E.DEPT_ID = D.DEPT_ID(+);SELECT EMP_NAME, DEPT_NAMEFROM EMPLOYEE E, DEPARTMENT DWHERE E.DEPT_ID(+) = D.DEPT_ID; ORACLE에서는 (+) 키워드를 사용하여 OUTER JOIN을 사용할 수 있다.ORACLE에서는 (+) 키워드로 FULL OUTER JOIN을 지원하지 않는다. 1234567891011SELECT EMP_NAME, DEPT_NAMEFROM EMPLOYEELEFT JOIN DEPARTMENTUSING (DEPT_ID)ORDER BY EMP_NAME;SELECT EMP_NAME, DEPT_NAMEFROM EMPLOYEEFULL JOIN DEPARTMENTUSING (DEPT_ID)ORDER BY EMP_NAME; ANSI 표준으로는 LEFT|RIGHT|FULL [OUTER] JOIN .. ON|USING .. 을 사용한다FULL OUTER JOIN은 ANSI 표준으로 사용한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SELECT E.EMP_NAME AS 직원, M.EMP_NAME AS 관리자, S.EMP_NAME AS 최고관리자FROM EMPLOYEE ELEFT OUTER JOIN EMPLOYEE MON ( E.MGR_ID = M.EMP_ID)LEFT OUTER JOIN EMPLOYEE SON ( M.MGR_ID = S.EMP_ID)ORDER BY 1;SELECT EMP_NAME, DEPT_NAMEFROM EMPLOYEEJOIN JOBUSING (JOB_ID)JOIN DEPARTMENTUSING (DEPT_ID)JOIN LOCATIONON ( LOC_ID = LOCATION_ID)WHERE JOB_TITLE = '대리'AND LOC_DESCRIBE LIKE '아시아%';SELECT J.JOB_TITLE, E.EMP_NAME, D.DEPT_NAME, L.LOC_DESCRIBE, C.COUNTRY_NAME, S.SLEVELFROM JOB J JOIN EMPLOYEE E USING (JOB_ID) JOIN DEPARTMENT D USING (DEPT_ID) JOIN LOCATION L ON ( D.LOC_ID = L.LOCATION_ID ) JOIN COUNTRY C USING (COUNTRY_ID) JOIN SAL_GRADE S ON ( E.SALARY BETWEEN S.LOWEST AND S.HIGHEST );SELECT EMP_NAME, JOB_ID, SALARYFROM EMPLOYEEWHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEE WHERE EMP_NAME = '나승원') AND SALARY &gt; (SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '나승원') 단일 행 서브쿼리이므로 비교 연산이 가능해지는 것이다. 123456789101112131415161718192021222324252627282930313233SELECT EMP_NAME, JOB_ID, SALARYFROM EMPLOYEEWHERE SALARY = (SELECT Min(SALARY) FROM EMPLOYEE);SELECT DEPT_NAME, Sum(SALARY)FROM EMPLOYEE LEFT JOIN DEPARTMENT USING (DEPT_ID)GROUP BY DEPT_ID, DEPT_NAMEHAVING Sum(SALARY) = (SELECT Max(Sum(SALARY)) FROM EMPLOYEE GROUP BY DEPT_ID);SELECT EMP_ID, EMP_NAME, '관리자' AS 구분FROM EMPLOYEEWHERE EMP_ID IN (SELECT MGR_ID FROM EMPLOYEE)UNIONSELECT EMP_ID, EMP_NAME, '직원'FROM EMPLOYEEWHERE DEPT_ID NOT IN (SELECT MGR_ID FROM EMPLOYEE WHERE MGR_ID IS NOT NULL)ORDER BY 구분, EMP_ID; 다중 행 서브쿼리에서는 IN, ANY, ALL 등의 키워드를 사용한다NOT IN 키워드를 사용할 경우 서브쿼리에서 NULL을 리턴해서는 안된다.SET 연산자 : UNION, UNION ALL (중복 허용), INTERSECT (교집합), MINUS (차집합)UNION 을 하기 위해서는 컬럼의 갯수와 각각의 데이터 타입이 일치해야 한다. 12345678910111213141516171819SELECT EMP_NAME, SALARYFROM EMPLOYEE JOIN JOB USING (JOB_ID)WHERE JOB_TITLE = '대리' AND SALARY &gt; ANY (SELECT SALARY FROM EMPLOYEE JOIN JOB USING (JOB_ID) WHERE JOB_TITLE = '과장');SELECT EMP_NAME, SALARYFROM EMPLOYEE JOIN JOB USING (JOB_ID)WHERE JOB_TITLE = '대리' AND SALARY &gt; ALL (SELECT SALARY FROM EMPLOYEE JOIN JOB USING (JOB_ID) WHERE JOB_TITLE = '과장'); 다중 행 서브쿼리일 경우 정확한 비교가 되지 않는다, 범위로만 비교해야.ANY는 박스 내부의 조건, ALL은 박스 외부의 조건. = ANY는 IN과 동일한 결과. 12345678910111213SELECT EMP_NAME, JOB_TITLE, SALARYFROM (SELECT JOB_ID, TRUNC(Avg(SALARY), -5) AS JOBAVG FROM EMPLOYEE GROUP BY JOB_ID) V JOIN EMPLOYEE E ON ( JOBAVG = SALARY AND NVL(E.JOB_ID, ' ') = NVL(V.JOB_ID, ' ') ) LEFT JOIN JOB J ON ( E.JOB_ID = J.JOB_ID )ORDER BY E.JOB_ID; FROM 절에도 서브쿼리를 사용할 수 있다. (가상의 테이블을 만드는 개념)‘직급’ 별 ‘평균 급여’ 정보가 필요하므로 FROM절에 다중 열 서브쿼리가 필요하다 12345678910SELECT EMP_NAME, JOB_TITLE, SALARYFROM EMPLOYEE E LEFT JOIN JOB J ON ( E.JOB_ID = J.JOB_ID )WHERE SALARY = (SELECT TRUNC(Avg(SALARY), -5) FROM EMPLOYEE WHERE NVL(JOB_ID, ' ') = NVL(E.JOB_ID, ' '))ORDER BY E.JOB_ID; 동일한 결과를 내지만 구현 방식은 다양하다. FROM 절로 JOIN을 하여 사용하는 인라인 뷰의 경우 WHERE 조건 절에서 비교 형태로 다중 열 서브쿼리를 사용하는 경우 WHERE 조건 절에서 상관관계 서브쿼리를 사용하는 경우 상관관계 서브쿼리는 메인 레코드의 횟수만큼 돌아야 하므로 비효율적일 수 있다.즉, 인라인뷰가 더 빠를 것이라고 예상할 수 있다.그러나 이는 상황에 따라 다를 수 있으므로 레코드의 수를 보며 적절히 판단하여야 한다 WHERE와 HAVING 절의 서브쿼리를 통해서 INSERT, DELETE 등 다양한 일을 수행할 수 있다.","link":"/2019/07/16/Database/190716 - Oracle - SELECT/"},{"title":"Lecture Note - from java to spring","text":"특징 Write Once, Run Anywhere 이식성이 상당히 좋다. *.java -&gt; *.class -&gt; interpreter -&gt; output 자바는 쓰레드 기반이다. 현장 투입시 하는 것 빌드 자동화 툴(Maven) 선정 통합개발환경 설치 형상관리 툴(git) 지속적 통합(Jenkins) JDK란 개발 툴 Class 란 설계도. 객체지향이란 Real World의 Object -&gt; 추상화 (Class) 명사적 특징 -&gt; 변수 동사적 특징 -&gt; 메서드 클래스는 객체가 아니다!클래스로부터 실행환경에서 객체를 추출해 낼 수 있다. Instance가 객체다. 클래스에 정의된 변수와 메서드는 클래스가 아닌 인스턴스의 소유다. 응집력은 높아야 하며 결합도는 낮춰야 한다.클래스란 인스턴스를 생성하기 위한 하나의 템플릿 (설계도면) 화면을 담당하는 presentation layer의 클래스가 Business logic을 포함하면 안된다. Presentation -&gt; Business logic -&gt; Data access(Persistence) 클래스 클래스 내부에 public static void main을 가지고 있어야 인터프리트가 가능하다. main을 갖고있지 않는 클래스는 인스턴스를 만들기 위해서 존재한다. 1. 변수1접근지정자 데이터타입 변수명; 데이터 타입 : 숫자형, 문자형, 논리형 byte, short, int, long / float, double / char / boolean 기본 : 값을 담음 (내부적으로는 값을 담는다) 참조 : 주소값을 담음 (값을 직접적으로 할당받을 수 없음) 보통 멤버변수는 Critical Section으로 보고 직접 접근 못하도록 가시성을 부여해준다. 지역변수는 메서드와 라이프사이클을 같이한다. 전역변수는 인스턴스와 라이프사이클을 같이한다. Static 변수는 쓰레드와 라이프사이클을 같이한다. 지역변수는 선언 후 초기화 하지 않으면 문법적으로 에러가 발생한다. 2. 메서드123접근지정자 리턴타입 메서드이름(파라메타_타입){ 업무로직} public / protected / default / private 3. 생성자 Like a Method 메서드가 아니다. VO / ENTITY / DTO VO : Back-end단에서 넘어운 데이터 DTO : Front-end에서 넘어온 데이터 (Data Transfer Object) 정형화 되어있지는 않으나 input parameter를 받아올 때 특정 멤버변수를 제외하고 null로 받아서 객체로 넘겨준다면 dto를 사용한다.또한, parameter의 수가 많지 않다면 map에 담아서 컨트롤러까지 넘겨주기도 한다. 레이어 Presentation LayerBusiness LayerPersistence Layer 각 레이어는 각각의 class를 갖는다. Persistence Layer는 DB와 통신한다. ResultSet을 Instance로 만들어야 한다. 1개의 레코드 = 1개의 인스턴스 즉, 현장에서는 테이블 스키마와 동일한 VO를 만드는 경우가 많다. Collection API(ex. 배열)에 담아서 다음 layer에 전달한다 각 클래스의 관계를 명확하게 이해하자! Controller : Presentation Layer (받는 곳)View : Presentation Layer (보여주는 곳)Model : Business &amp; Persistence Layer 생성자 new 연산자 뒤에서만 사용이 가능하다멤버변수에 대한 초기화를 담당한다기본생성자 / 스페셜 생성자 스페셜 생성자는 기본 생성자를 먼저 만들고 쓰는게 좋다 오버로딩 매개변수의 타입과 갯수가 달라야 한다오버로딩된 메서드의 업무 로직은 동일해야 한다 JVM JVM은 메모리 섹터로 이루어져 있다.다섯개의 메모리 영역이 있다. Static / Method Area Stack Heap - Literal(Constant) Pool 실행 순서 javac ~.javajava ~ 실행 할 경우 각 클래스에서 Static 키워드가 붙은 메서드와 변수, 일반 메서드가 Static / Method Area에 올라온다. public static void main(String[] args) 메서드를 찾아서 Execution Stack에 올린다 가비지 콜렉터 참조가 끊어진 객체들이 쌓여서 메모리 가용성이 떨어지면 GC 쓰레드가 작동한다.finalize() 메서드를 오버라이드해서 명시적으로 호출할 수는 있으나 그 실행 시점은 랜덤이다. 리터럴 변수에 할당되는 값문자(‘’), 문자열(“”), 정수, 실수, 논리(true / false) 파라메터 / 매개변수 Parameter : 전달되는 값Argument : 함수에 정의된 변수 Heap에 매개변수 값이 들어간다. (Literal Value) Has-A / Use-A Has-A객체의 라이프사이클이 나와 같을 때Use-A객체의 라이프사이클이 나와 같지 않을 때 객체지향의 특징 - 은닉화 / 상속 / 다형성 / 추상화 은닉화 : 객체의 타입 등 정보를 감출 수 있어야 함. (추상화와 연계되어 있음) Information Hiding 상속 : super(부모클래스) / this. 부모는 자식에게 필요로 되어지는 공통의 기능들을 내려준다. (IS-A 관계)인어공주 IS-A 사람 내려갈수록 클래스는 구체화, 올라갈수록 클래스는 일반화(추상화) 타입 : 부모 &gt; 자식 포함관계 : 부모 &gt; 자식 자바는 컴파일 언어 -&gt; 컴파일 타임에 Data Type을 체크한다. WEB FRAMEWORK들은 코드 상에 extends, implements 가 없더라도 그러한 역할을 해준다는 것을 알자. 다형성 : 관리의 효율성을 위해서 객체의 다형성 메서드의 다형성 (오버로딩 / 오버라이딩) 매개변수의 다형성 항상 캐스팅을 생각하자 추상화 : 구현을 감춘다. Implementation Hiding 추상클래스 / 인터페이스 실 타입을 숨기고, 명세는 동일하지만 그 구현을 감춘다 부모 클래스는 인스턴스를 생성하는 경우가 많지 않다. 배열 객체로 취급 fixed size same type index 0 부터 다형성을 적용하여 배열에 여러 타입의 데이터를 넣었을 경우 런타임시점에 instanceof 키워드로 리얼타입을 체크한다 반복을 수행하는 방법 for-loop enhanced for loop (for-each) : JIT compiler에 의한 내부순환자 iterator : 가장 빠름 파일입출력추상클래스 / 인터페이스 공통점 : 표준의 역할을 하기 위함 차이점 : 객체 생성이 되지 않음 추상클래스 : 변수 + 메서드를 포함하고 있음 자식클래스는 모든 추상메서드를 오버라이드 해야만 인스턴스 생성 가능 모든 서브타입이 기능을 공유하고, 특정 기능은 동일한 구현을 공유해야 할 때 추상클래스를 쓰면 용이하다. 인터페이스 : 상수(잘 안씀) + 추상 메서드 다중 구현 가능 상속받는 클래스는 인터페이스의 모든 추상메서드를 오버라이드 해야함 ENUM 열거형 데이터 타입public static final 로 상수를 선언했을 때, 다른 사용자가 악의적으로 엉뚱한 상수값을 넣는 것을 방지 할 수 있음 디자인패턴 싱글톤 패턴 : 무분별한 객체 생성을 막기 위해 필요 커맨드 패턴 팩토리 패턴 빈(Bean) 개발자가 생성하지 않고 생성된 객체 싱글톤의 문제 : Bottleneck Bean 객체의 생성을 Singleton이 아닌 Request시 마다로 할 수 있음 (WAS) Activated / Deactivate 할 수 있음 예외 (Exception) Object &lt;- Throwable &lt;- Exception Compile Runtime T-C-F-T-C 형식을 즐겨 쓴다결과에 대해 명확히 이해한 후에 Throws를 할지 T-C를 할지 결정해야 한다.T-F 구문이 있을 수 있다 (내가 직접 예외를 던질 경우(throws)에 사용한다) Collection API fixed size가 아닌 배열. Object만 담을 수 있다. Java 5 버전 이후에는 auto-Boxing이 되므로 int도 담을 수 있다. Same Type이 아니어도 된다. size() 메서드를 이용해서 크기를 알 수 있다. Index를 쓸 필요가 없다. List - Vector, Linked, ArrayList 중복 허용, Natural Order Set - HashSet 중복 x, 순서 x Map - HashMap(key, value) 중복 x, 순서 x Vector / ArrayList의 차이 쓰레드 WAS 서버가 T-S를 보장한다.그렇기 때문에 웹에서는 멤버변수를 잘 쓰지 않는다. Stream 데이터가 지나다닐 수 있는 통로.System.out.printl() &lt;-&gt; System.in.read() java.io.* Byte 형식으로 입출력하는 스트림 (한글을 사용하면 깨진다) xxxStream Character 형식으로 입출력하는 스트림 xxxReader / xxxWriter Byte Stream을 활용한 객체 스트림 ObjectInput/OutputStream 콘솔 입출력, 파일 입출력, 원격 통신 자바에서 객체를 전송할 때는 Serializable Interface를 Implements 해야 함.Marker Interface : 인터페이스이지만 추상메서드가 없음.객체를 ByteStream으로 보내고 받음.Stream 자체와 transient 키워드가 붙은 변수는 직렬화가 되지 않는다. Thread 구현 방식 Thread Class Runnable Interface run() : Thread의 수행 업무 쓰레드는 동시성과 제어가 중요한 관점 [출처 : https://www.javamadesoeasy.com/2015/03/thread-states-thread-life-cycle-in-java.html] 스케쥴링 방식 Time Slice 방식 (Ordering X 랜덤) Turn Around 방식 (Ordering O 메모리 순위로) Method join() : 데몬쓰레드가 기다림 sleep() : 쓰레드를 재워둠 wait(), notify() : Syncronized Block에서만 사용 가능 notifyAll() : 모든 쓰레드가 깨어남 threadIsAlive(), currentThread() : 현재 동작하는 쓰레드를 알 수 있음 interrupt() : 쓰레드를 킬함 JDBC Driver loading Connection (url, user, pwd) Statement (SQL) 실행 excuteQuery() : resultSet -&gt; select excuteUpdate() : int -&gt; insert / update / delete ResultSet 핸들링 Close() 위 절차는 모두 Exception을 발생시킨다. try ~ catch 가 필요하다. 이러한 것들을 모두 감싸는 프레임워크가 myBatis. connection() ~ close()의 작업이 반복적으로 실행되면 오버헤드가 심해지므로 현업에서는 Connection Pool을 사용한다. 백엔드의 레이어 Presentation Layer Servlet.java (Controller) java + html 분기하는 것이 Controller의 역할이다. xxx.jsp (View) html + java Business Layer (Model) xxxServiceImpl Persistence Layer (Model) xxxImpl Front-Controller Pacade Pattern / Delegate Pattern request를 Factory로 넘겨서 Controller를 생성함 Web Servlet : Controller의 역할 JSP : View의 역할 Web Server + Container(java 실행환경) = WAS Container Catalina : Servlet 동작 Jasper : JSP 동작 Dynamic Web Project http: //server_ip/contextName/servletName or xxxxx.jsphttp: //server_ip/contextName/xxxxx?key=value&amp;key=valueURL or URI ? queryString lib : 라이브러리들 web.xml : Deploy Descriptor build : Output Java Resources src/main/java : 자바 파일 src/resources : xml 파일, sql 파일 등 src/test : 테스트 파일 (ex. jUnit) Servlet &lt;- GenericServlet &lt;- HttpServlet Servlet의 메서드 3개 init() service() doGet() doPost() destory() : re-compile 될 때 등 사용. 보통 외부자원과의 연결을 끊어주는 역할을 수행함. HttpServlet &lt;- MyServlet위의 3개의 메서드를 오버라이딩해서 사용한다. 최초의 request가 들어왔을 때 객체가 생성(LazyLoading)되고, 이후에는 init() 이후에 thread만 매번 생성된다. 일반 xxx.java는 Request, Response 객체를 핸들링 할 수 없으나, Dispatcher Servlet(Front-Controller)로 부터 Delegate 함으로써 Controller 역할을 수행 할 수 있게 된다. 각 Controller는 사용자 Request URL을 매핑해서 사용한다. 데이터 Validation Check 데이터에 대한 유효성(Validation) 체크는 네트워크 트래픽을 낭비하지 않기 위해 프론트엔드에서 Script로 하는 것이 좋다. 백엔드에서도 Filter를 이용해서 유효성을 체크해야 한다. 즉, 컨트롤러의 실질적인 일이란 객체를 만들어서 서비스에 맡기는 것이다. (Model과 dependency를 갖는 것이다.) 화면 분기 방식 redirect forward Forward라면 Request에 데이터를 심어서 Response에서 그 데이터를 사용할 수 있게끔 한다.Redirect 하는 상황에서 데이터를 공유하려면 Request가 아닌 Session에 데이터를 심어야 한다. Java와 jsp간 데이터 교환 방법 컨테이너 내부에 객체를 공유할 수 있는 공간이 있음 컨테이너 내부의 4가지 Scope 영역 Application Context : 컨테이너 내부에서 동작하는 객체를 유지 (server가 shutdown 되기 전까지 - ex. 로그인 중인 사용자의 정보), 가장 넓은 Scope를 가진다. Session Context : Last Access Time으로부터 일정 기간동안 유지된다. Request : Request는 해당 요청이 처리되면 데이터가 사라진다. (Model(@ModelAttribute), RedirectAttributes) Page : 자기 페이지 내부에서만 작동하는 Scope. 제일 작은 범위. 서블릿이 자체적으로 JSP에 데이터를 던져줄 수 없으므로, Servlet이 어딘가에 심어놓은(setAttribute()) 데이터를 JSP가 가져오는(getAttribute()) 것이다. JSP에서 해당 데이터를 이용하기 위해서는 JAVA의 객체를 사용해야 하므로, JAVA의 코드를 JSP(HTML) 내에 삽입하기 위한 태그들이 존재하게 되는 것이다. 자동로그인의 경우는 Cookie를 이용해서 백엔드에서 Interceptor로 작동된다. 프론트엔드에서 시각화 하는 방법은 script를 사용한다. 즉, JAVA의 객체를 script가 가져다 쓸 수 있게끔 해야 하기 때문에 JSON과 같은 방식이 필요하다. HTML HTML에서 서버와 통신하는 방법은 3개가 있다. a tag get 방식 form tag method 속성으로 action의 방식을 설정 가능 input tag name 속성에 값을 담아서 넘긴다. 현업에서는 일반적으로 name과 id의 이름을 동일하게 준다. name Attribute, Table Column, DTO Field는 동일하게 주어야 한다 AJAX JSP JSP에는 기본적으로 4개의 tag가 있다. &lt;%@ : Directives tag (지시자) page (import) include taglib &lt;%! : Declaration tag (선언문) 변수, 메서드 정의 &lt;% : Scriptlet tag 서블릿의 service()와 동일한 역할을 하는 태그 request, response등 내장객체를 이용한 코딩이 가능해짐 &lt;%= : Expression tag 출력시 사용. semicolon 사용 불가 그러나 위의 태그들을 사용하여 java 코드를 넣을 경우 뷰를 처리하는 JSP 코드가 너무 복잡해지는(이질감이 드는) 문제점이 발생-&gt; JSTL, EL JSTL + EL EL (Expression Language) : 내장객체와 속성 값을 가져오기 매우 편함 직접적으로 속성 값을 가져오는 것이 아니고 getter를 사용하여 가져온다. 내부에 연산자를 사용할 수 있다. JSTL (JSP Standard Tag Library) jstl/core : 논리적 처리, 변수 지원, 흐름 제어 등의 태그들 jstl/functions : EL에서 사용 가능한 함수 태그들 1234567891011${ param.name }&lt;c:if test = \"${ testSession ne null }\"&gt; ${ testSession[\"id\"] } &lt;c:out value=\"&lt;h2&gt;${ testSession.id }&lt;/h2&gt;\" escapeXml=\"true\" /&gt;&lt;/c:if&gt;&lt;c:if test=\"${f:length(list) &gt; 0}\"&gt; &lt;c:forEach var=\"obj\" items=\"${list}\"&gt; ${obj.id} &lt;br/&gt; &lt;/c:forEach&gt;&lt;/c:if&gt; 세션과 쿠키 세션 (Session) : 서버에 저장, 객체도 저장 가능 쿠키 (Cookie) : 클라이언트에 저장, 문자열만 저장 가능 세션은 공통 업무와 보안 문제를 고려할 때 사용 Script 페이지가 멈춰있는 상태에서 (JSP를 문서로 봄) Document를 건드리는 기술 ex) 동적인 페이지 구성 / 입력 값에 대한 유효성 체크 + Script를 이용한 서버와의 통신. But, Response가 없음. 응답이 Request에 담겨있다. (페이지의 Reloading이 발생하지 않음)-&gt; 비동기 통신방식(AJAX) XML(복잡) -&gt; JSON JAVA의 객체를 Object로 관리하기 위해서는 형식을 맞춰주어야 한다. 서버에서 Session/Request Scope에 데이터를 JAVA type으로 심는 방식이 아니고 JSON 형식으로 변경해서 내려주어야 한다. JQuery1234567891011$(document).ready(function() { $(\"#btn\").click(function() { /* console.log(obj); console.log(ary); $(\"#result\").text(obj.id + \" \" + obj.pwd); */ $.each(ary, function(idx, data) { $(\"#result\").append(\"&lt;H1&gt;\" + obj.id + \" \" + obj.pwd+ \"&lt;/H1&gt;\"); // $(\"#result\").html(\"&lt;H1&gt;\" + obj.id + \" \" + obj.pwd+ \"&lt;/H1&gt;\"); }); });}); AJAX1234567891011$(\"#ajaxBtn\").click(function() { $.ajax({ url : \"./ajaxCtrl\", type : \"post\", data : { maker : $(\"#maker\").val()}, dataType : \"json\", success : function(obj){ alert(obj); } });}); 비동기 방식으로 통신할 때 객체를 넘기면(Response를 넘기지 않으면) MVC를 타지 않는다.@ResponseBody 키워드를 사용하면 Jackson 라이브러리가 JSON 형식으로 변환해서 보내준다. 12345@RequestMapping(\"/doJSON.sinc\")public @ResponseBody ProductVO doJSON() { ProductVO vo = new ProductVO(\"샘플\", 30000); return vo;} 주석 HTML : &lt;!– JSP : &lt;%– 클라이언트가 볼 수 없음, 파싱 시 에러 방지 Maven https://mvnrepository.com/ Spring Inversion Of Control (제어의 역행) Dependency Injection Dependency Lookup Container를 Setting하는 방법 XML (Schema) Annotation 위의 방법들을 이용해서 Ctrl &lt;- Service &lt;- DAO를 Dependency Injection함 Presentation Layer(Ctrl)의 XML 1개servlet-context.xml : resources, views Business Layer(Service, DAO)의 XML 1개root-context.xml : DB Property 설정, Service/DAO 객체 등록 -&gt; 총 2개의 Spring 설정 XML 파일이 생성된다. Web.xml : 프로젝트에 대한 환경 설정. context 파일과 Servlet(Front Controller) 등록. -&gt; Factory의 역할을 함 Annotation을 사용해 서블릿 등록 가능 -&gt; 최종적으로 Zero Configuration 지향 가능 의존성 주입 방법 @Resource : Java 표준. name으로 식별이 가능함 @Autowired : Spring. Ambiguity 문제 발생 가능성 (Type Check -&gt; Variable Name Check) @Qualified @Inject 12345&gt; &lt;bean&gt;&gt; &lt;property&gt;&gt; &lt;constructor-arg&gt;&gt; &lt;/bean&gt;&gt; -&gt; Setter Injection (Property Injection) LookUp(main Class의 흐름) 역시 Spring이 해준다. AOP SpringMVC [출처 : https://iotsw.tistory.com/tag/HandlerMapping] web.xml(Deploy Decriptor)에 Dispatcher Servlet을 등록함 스키마 기반으로 구성하면 multi-action Controller를 구현할 수 없음 -&gt; Controller Annotation Controller는 Request에 대해 화면을 분기해줌 servlet-context.xml에 ViewResolver가 등록되어 있으며, annotation-driven으로 Mapper도 등록되어 있음 root-context.xml이 모델/DAO에 대한 설정을 지니고 있음 이 모든 것들이 web.xml에 의해 로드되므로 스프링의 컨테이너가 사용가능해짐 Client -&gt; Dispatcher Servlet-&gt; Handler Mapping&lt;-&gt; Controller 컨트롤러 메서드의 리턴타입은 3개 ModelAndView String Void Request 되는 URI과 같은 JSP를 찾음. (경로 주의) -&gt; ViewResolver-&gt; View 기본 페이지 분기는 Forward Ctrl의 Parameter는 지정하기 나름 Model 객체가 Request Scope을 가짐 객체생성에 관련한 Annotation @Component @Controller @Service @Repository xxxMapper 가 하는 일 xxx-context.xml을 스캔 @Annotation 스캔 JUnit 모듈 단위테스트를 용이하게 도와주는 라이브러리 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= {\"file:src/main/webapp/WEB-INF/spring/**/root-context.xml\"})public class AopMain { @Resource(name=\"serviceTarget\") private SincService service; @Test public void caller() { String msg = service.sayEcho(\"이거 뭐지요? AOP~~~~\"); System.out.println(msg); }} filter, interceptor, AOP[출처 : https://goddaehee.tistory.com/154] filter : Web Container에서 동작, Servlet 이전사용자의 요청이 post 방식일때만 작동한다. -&gt; get 방식에서는 한글을 가급적 사용하지 않는다. ex) 한글 Encoding 작업 interceptor : Dispatcher -&gt; Controller 이전 (servlet-context) Request 정보를 지니고 있다가 로그인 후 이용 가능한 장점도 있다. AOP : 서비스 이전 (root-context) Filter 12345678910111213&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; web.xml Interceptor 1234567891011121314public class TestInterceptor extends HandlerInterceptorAdapter{ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {// if(request.getSession().getAttribute(\"loginUser\") == null) {// redirect// } System.out.println(\"interceptor &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pre\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"interceptor &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; post\"); }} 12345678&lt;beans:bean id=\"sampleInter\" class=\"com.sinc.project.interceptor.TestInterceptor\" /&gt;&lt;interceptors&gt; &lt;interceptor&gt; &lt;mapping path=\"/user/login.sinc\"/&gt; &lt;beans:ref bean=\"sampleInter\"/&gt; &lt;/interceptor&gt;&lt;/interceptors&gt; servlet-context.xml Spring AOP AOP 구현 방법 3개 POJO Class Spring API Annotation 용어 설명 Aspect - 공통 관심사항 객체 (ex. 트랜잭션, 로깅 .. ) JoinPoint - Aspect가 적용되는 지점 (마킹) Argument로 받을 경우 타겟이나 진행 상황 등의 정보를 알 수 있다. PointCut - 적용될 Joinpoint (포인트) Advice - before / after-returning / after-throwing / after / around Weaving - 어떤 Advice를 어떤 Pointcut에 적용시킬지 Advisor 12345678910111213&lt;context:component-scan base-package=\"com.sinc.project.**\" /&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;!-- aop --&gt;&lt;bean id=\"loginAspect\" class=\"com.sinc.project.aop.common.LoginAspect\"&gt;&lt;/bean&gt;&lt;bean id=\"serviceTarget\" class=\"com.sinc.project.aop.core.SincServiceImpl\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(public * com.sinc.project..*Impl.say*(..))\" id=\"echoing\"/&gt; &lt;aop:aspect id=\"beforeAspect\" ref=\"loginAspect\"&gt; &lt;aop:before pointcut-ref=\"echoing\" method=\"before\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; root-context.xml 1234567891011121314@Component(\"loginAspect\")@Aspectpublic class LoginAspect { @Before(\"execution(public * com.sinc.project..*Impl.say*(..) \") public void before(JoinPoint join) { System.out.println(\"aspect &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; before advice\"); } @AfterThrowing(pointcut = \"execution(public * com.sinc.project..*Impl.say*(..))\", throwing = \"e\") public void throwing(JoinPoint point, Exception e) { e.printStackTrace(); }} 동적 쿼리123456789101112131415&lt;select id=\"search\" parameterType=\"map\" resultType=\"board\"&gt; SELECT SEQ, TITLE, WRITER, TO_CHAR(REGDATE, 'RRRR-MM-DD') AS REGDATE, VIEWCNT FROM SPRING_BOARD_TBL &lt;where&gt; &lt;if test=\"#{type} == 'title'\"&gt; TITLE LIKE '%' || #{title} || '%' &lt;/if&gt; &lt;if test=\"#{type} == 'writer'\"&gt; WRITER LIKE '%' || #{keyword} || '%' &lt;/if&gt; &lt;/where&gt; ORDER BY 1 DESC&lt;/select&gt;&lt;-- WHERE SALARY &lt;![CDATA[ &gt; ]]&gt; 1000 --&gt; 문제 배열(2차원), 조건처리, 스트림(파일입출력)","link":"/2019/07/10/Web/190710 - Web Lecture Note/"}],"tags":[{"name":"Book","slug":"Book","link":"/tags/Book/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"Architecture","slug":"Architecture","link":"/tags/Architecture/"},{"name":"Oracle Database","slug":"Oracle-Database","link":"/tags/Oracle-Database/"},{"name":"Sort Algorithm","slug":"Sort-Algorithm","link":"/tags/Sort-Algorithm/"},{"name":"Frontend","slug":"Frontend","link":"/tags/Frontend/"},{"name":"Programming level","slug":"Programming-level","link":"/tags/Programming-level/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"Clustering","slug":"Clustering","link":"/tags/Clustering/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring Framework","slug":"Spring-Framework","link":"/tags/Spring-Framework/"}],"categories":[{"name":"Books","slug":"Books","link":"/categories/Books/"},{"name":"Cloud","slug":"Cloud","link":"/categories/Cloud/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Algorithms","slug":"Algorithms","link":"/categories/Algorithms/"},{"name":"Manual","slug":"Manual","link":"/categories/Manual/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"AWS","slug":"Cloud/AWS","link":"/categories/Cloud/AWS/"},{"name":"Web","slug":"Programming/Web","link":"/categories/Programming/Web/"}]}